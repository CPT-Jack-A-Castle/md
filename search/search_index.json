{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Unofficial Monero Documentation \u00b6 Work in Progress \u00b6 Monerodocs attempts to organize basic technical knowledge on Monero in one place. While technical explanations are out there, knowledge is scattered through reddit posts, git comments, stack exchange answers, chat logs and the source code. This makes it hard to find complete and up-to-date explanations on advanced topics. The goal is to educate and onboard power users faster. Please submit your feedback and corrections directly on github . Find my contact details at qertoip.com .","title":"Home"},{"location":"#unofficial-monero-documentation","text":"","title":"Unofficial Monero Documentation"},{"location":"#work-in-progress","text":"Monerodocs attempts to organize basic technical knowledge on Monero in one place. While technical explanations are out there, knowledge is scattered through reddit posts, git comments, stack exchange answers, chat logs and the source code. This makes it hard to find complete and up-to-date explanations on advanced topics. The goal is to educate and onboard power users faster. Please submit your feedback and corrections directly on github . Find my contact details at qertoip.com .","title":"Work in Progress"},{"location":"multisignature/","text":"Multisignature \u00b6 In cryptocurrencies, multisig feature allows to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with M-of-N keys. Example use cases: shared account (1-of-2; both husband and wife individually have full access to their funds) consensus account (2-of-2; both husband and wife must agree to spend their funds) threshold account (2-of-3; an escrow service is involved as an independent 3rd party, to co-sign with either the seller, or with the buyer, if seller and buyer do not agree) secure account (2-of-3; a single owner controlls all 3 keys but secures them via a different means to diversify risks) arbitrary threshold account (M-of-N; some cryptocurrencies provide full flexibility on the number of signers) Monero multisignature \u00b6 Monero doesn't directly implement multisignatures (at least not in a classical sense). Monero emulates the feature by secret splitting. Transactions are still signed with a single spend key. The spend key is a sum of all N private keys. The rationale for such design is to decouple multisig from ring signatures. Let's consider the 2-of-3 scheme. We have 3 participants. Each participant is granted exactly 2 private keys in a way that pairs do not repeat between participants. This way any 2 participants together have all 3 private keys required to create the private spend key. Multi-signing is a wallet-level feature. There is no way to learn from the blockchain which transactions were created using multiple signatures. It is also worth noting in Monero there is no multisig addresses as such. Address structure does not care how the underlying private spend key got created. After multisig wallet setup every participant ends up knowing the public address and private view key. This is necessary for participants to recognize and decipher transactions they are supposed to co-sign. Multisig wallet setup \u00b6 Multisig feature is only available via a command line wallet. You should be familiar with the CLI wallet before playing with multisig. Let's consider a 2-of-3 scheme as it generalizes well. 0. Open your wallet \u00b6 Access your (stagenet) wallet: ./monerod --stagenet --daemon # Run your full node; make sure it is fully synced ./monero-wallet-cli --stagenet --wallet-file=... # Run your wallet; make sure you have some funds to play with 1. prepare_multisig \u00b6 Every participant independently generates initialization data . This is not an address. Every participant sends his initialization data manually to all other participants over secure channel. 2. make_multisig \u00b6 Every participant applies initialization data from other participants. This results in a second round of initialization data . This is still not an address. Every participants sends his second round of init data to all other participants over secure channel. 3. finalize_multisig \u00b6 Every participant finalizes wallet creation by applying the second round of init data from all other participants. This finally results in a wallet public address and private view key to be known for all participants. Please note actions are symmetric for all participants. Even though we considered a 2-of-3 scheme, every participant cooperates with everyone else. The secret splitting is performed internally by the wallet. Secure sharing of initialization data between participants is manual. The wallet itself does not provide any secure communication channel. This is out of scope. Receiving funds \u00b6 Address built by multisig setup is like any other address. You can generate integrated addresses and subaddresses based on it. All participants are able to see incoming funds as they share the private view key. With a CLI, use the following commands to see incoming payments: address refresh show_transfers Spending funds \u00b6 TODO Reference \u00b6 https://monero.stackexchange.com/questions/5646/how-to-use-monero-multisignature-wallets-2-2-2-3","title":"Multisignature"},{"location":"multisignature/#multisignature","text":"In cryptocurrencies, multisig feature allows to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with M-of-N keys. Example use cases: shared account (1-of-2; both husband and wife individually have full access to their funds) consensus account (2-of-2; both husband and wife must agree to spend their funds) threshold account (2-of-3; an escrow service is involved as an independent 3rd party, to co-sign with either the seller, or with the buyer, if seller and buyer do not agree) secure account (2-of-3; a single owner controlls all 3 keys but secures them via a different means to diversify risks) arbitrary threshold account (M-of-N; some cryptocurrencies provide full flexibility on the number of signers)","title":"Multisignature"},{"location":"multisignature/#monero-multisignature","text":"Monero doesn't directly implement multisignatures (at least not in a classical sense). Monero emulates the feature by secret splitting. Transactions are still signed with a single spend key. The spend key is a sum of all N private keys. The rationale for such design is to decouple multisig from ring signatures. Let's consider the 2-of-3 scheme. We have 3 participants. Each participant is granted exactly 2 private keys in a way that pairs do not repeat between participants. This way any 2 participants together have all 3 private keys required to create the private spend key. Multi-signing is a wallet-level feature. There is no way to learn from the blockchain which transactions were created using multiple signatures. It is also worth noting in Monero there is no multisig addresses as such. Address structure does not care how the underlying private spend key got created. After multisig wallet setup every participant ends up knowing the public address and private view key. This is necessary for participants to recognize and decipher transactions they are supposed to co-sign.","title":"Monero multisignature"},{"location":"multisignature/#multisig-wallet-setup","text":"Multisig feature is only available via a command line wallet. You should be familiar with the CLI wallet before playing with multisig. Let's consider a 2-of-3 scheme as it generalizes well.","title":"Multisig wallet setup"},{"location":"multisignature/#0-open-your-wallet","text":"Access your (stagenet) wallet: ./monerod --stagenet --daemon # Run your full node; make sure it is fully synced ./monero-wallet-cli --stagenet --wallet-file=... # Run your wallet; make sure you have some funds to play with","title":"0. Open your wallet"},{"location":"multisignature/#1-prepare_multisig","text":"Every participant independently generates initialization data . This is not an address. Every participant sends his initialization data manually to all other participants over secure channel.","title":"1. prepare_multisig"},{"location":"multisignature/#2-make_multisig","text":"Every participant applies initialization data from other participants. This results in a second round of initialization data . This is still not an address. Every participants sends his second round of init data to all other participants over secure channel.","title":"2. make_multisig"},{"location":"multisignature/#3-finalize_multisig","text":"Every participant finalizes wallet creation by applying the second round of init data from all other participants. This finally results in a wallet public address and private view key to be known for all participants. Please note actions are symmetric for all participants. Even though we considered a 2-of-3 scheme, every participant cooperates with everyone else. The secret splitting is performed internally by the wallet. Secure sharing of initialization data between participants is manual. The wallet itself does not provide any secure communication channel. This is out of scope.","title":"3. finalize_multisig"},{"location":"multisignature/#receiving-funds","text":"Address built by multisig setup is like any other address. You can generate integrated addresses and subaddresses based on it. All participants are able to see incoming funds as they share the private view key. With a CLI, use the following commands to see incoming payments: address refresh show_transfers","title":"Receiving funds"},{"location":"multisignature/#spending-funds","text":"TODO","title":"Spending funds"},{"location":"multisignature/#reference","text":"https://monero.stackexchange.com/questions/5646/how-to-use-monero-multisignature-wallets-2-2-2-3","title":"Reference"},{"location":"technical-specs/","text":"Monero Technical Specs \u00b6 Live \u00b6 Monero blockchain is live since 18 April 2014 No premine, no instamine, no ICO, no token \u00b6 Monero had no premine or instamine Monero did not sell any token Monero had no presale of any kind Proof of Work \u00b6 CryptoNight v0 since block height 0 v1 since block height 1546000 (forked on 2018-04-06) v2 since block height 1685555 (forked on 2018-10-18) Changes every ~6 months to discourage ASIC-s Difficulty retarget \u00b6 every block based on the last 720 blocks (24h), excluding 20% of the timestamp outliers Block time \u00b6 2 minutes may change in the future as long as emission curve is preserved Block reward \u00b6 smoothly decreasing and subject to penalties for blocks greater then median size of the last 100 blocks (M100) ~3.8 XMR as of Sep 2018; for the current reward check the coinbase transaction of the latest block Block size \u00b6 dynamic maximum of two times the median size of the last 100 blocks (2 * M100) ~100KB as of Aug 2018; check the latest block size Emission curve \u00b6 Main emission \u00b6 first, the main emission is about to produce ~18.132 million coins by the end of May 2022 as of Aug 2018 the emission is about 20 XMR per 10 minutes see charts and details Tail emission \u00b6 the tail emission kicks in once main emission is done it will produce 0.6 XMR per 2-minute block this translates to <1% inflation decreasing over time Max supply \u00b6 ~18.132 million XMR + 0.6 XMR per 2 minutes technically infinite but practicaly deflationary if accounted for lost coins Divisibility \u00b6 Monero is divisible up to 12 digits The smallest unit is called piconero and equals 1e-12 XMR, or 0.000000000001 XMR Sender privacy \u00b6 ring signatures the ring size is 11 (10 decoys) assurance: probabilistic / plausible deniability Recipient privacy \u00b6 stealth addresses assurance: strong Amount privacy \u00b6 ring confidential transactions assurance: strong IP address privacy \u00b6 there is an ongoing effort to integrate I2P into Monero - the Kovri project assurance: none at the moment - please use TOR or I2P","title":"Technical specs"},{"location":"technical-specs/#monero-technical-specs","text":"","title":"Monero Technical Specs"},{"location":"technical-specs/#live","text":"Monero blockchain is live since 18 April 2014","title":"Live"},{"location":"technical-specs/#no-premine-no-instamine-no-ico-no-token","text":"Monero had no premine or instamine Monero did not sell any token Monero had no presale of any kind","title":"No premine, no instamine, no ICO, no token"},{"location":"technical-specs/#proof-of-work","text":"CryptoNight v0 since block height 0 v1 since block height 1546000 (forked on 2018-04-06) v2 since block height 1685555 (forked on 2018-10-18) Changes every ~6 months to discourage ASIC-s","title":"Proof of Work"},{"location":"technical-specs/#difficulty-retarget","text":"every block based on the last 720 blocks (24h), excluding 20% of the timestamp outliers","title":"Difficulty retarget"},{"location":"technical-specs/#block-time","text":"2 minutes may change in the future as long as emission curve is preserved","title":"Block time"},{"location":"technical-specs/#block-reward","text":"smoothly decreasing and subject to penalties for blocks greater then median size of the last 100 blocks (M100) ~3.8 XMR as of Sep 2018; for the current reward check the coinbase transaction of the latest block","title":"Block reward"},{"location":"technical-specs/#block-size","text":"dynamic maximum of two times the median size of the last 100 blocks (2 * M100) ~100KB as of Aug 2018; check the latest block size","title":"Block size"},{"location":"technical-specs/#emission-curve","text":"","title":"Emission curve"},{"location":"technical-specs/#main-emission","text":"first, the main emission is about to produce ~18.132 million coins by the end of May 2022 as of Aug 2018 the emission is about 20 XMR per 10 minutes see charts and details","title":"Main emission"},{"location":"technical-specs/#tail-emission","text":"the tail emission kicks in once main emission is done it will produce 0.6 XMR per 2-minute block this translates to <1% inflation decreasing over time","title":"Tail emission"},{"location":"technical-specs/#max-supply","text":"~18.132 million XMR + 0.6 XMR per 2 minutes technically infinite but practicaly deflationary if accounted for lost coins","title":"Max supply"},{"location":"technical-specs/#divisibility","text":"Monero is divisible up to 12 digits The smallest unit is called piconero and equals 1e-12 XMR, or 0.000000000001 XMR","title":"Divisibility"},{"location":"technical-specs/#sender-privacy","text":"ring signatures the ring size is 11 (10 decoys) assurance: probabilistic / plausible deniability","title":"Sender privacy"},{"location":"technical-specs/#recipient-privacy","text":"stealth addresses assurance: strong","title":"Recipient privacy"},{"location":"technical-specs/#amount-privacy","text":"ring confidential transactions assurance: strong","title":"Amount privacy"},{"location":"technical-specs/#ip-address-privacy","text":"there is an ongoing effort to integrate I2P into Monero - the Kovri project assurance: none at the moment - please use TOR or I2P","title":"IP address privacy"},{"location":"cryptography/base58/","text":"Base58 \u00b6 Base58 is a binary-to-text encoding scheme. It is similar to Base64 but has been modified to avoid both non-alphanumeric characters and letters which might look ambiguous when printed. The characters excluded in relation to Base64 are: IOl0+/ Base58 does not strictly specify the format. This results in some implementations being incompatible with others, for example with regard to alphabet order. For details, see Wikipedia . Base58 in Monero \u00b6 Monero has its own variant of Base58. In Monero the Base58 encoding is performed in 8-byte blocks, except the last block which is the remaining (8 or less) bytes . The 8-byte block converts to 11 or less Base58 characters. If the block converted to less then 11 characters, the output is padded with \"1\"s (0 in Base58). The final block is padded as well to whatever would be the maximum size of this number of bytes encoded in Base58. The advantage of Monero implementation is that output is of a fixed size which is not the case with plain Base58. The disadvantage is that default libraries won't work. For details, see reference C++ Base58 implementation and unofficial Python Base58 implementation.","title":"Base58"},{"location":"cryptography/base58/#base58","text":"Base58 is a binary-to-text encoding scheme. It is similar to Base64 but has been modified to avoid both non-alphanumeric characters and letters which might look ambiguous when printed. The characters excluded in relation to Base64 are: IOl0+/ Base58 does not strictly specify the format. This results in some implementations being incompatible with others, for example with regard to alphabet order. For details, see Wikipedia .","title":"Base58"},{"location":"cryptography/base58/#base58-in-monero","text":"Monero has its own variant of Base58. In Monero the Base58 encoding is performed in 8-byte blocks, except the last block which is the remaining (8 or less) bytes . The 8-byte block converts to 11 or less Base58 characters. If the block converted to less then 11 characters, the output is padded with \"1\"s (0 in Base58). The final block is padded as well to whatever would be the maximum size of this number of bytes encoded in Base58. The advantage of Monero implementation is that output is of a fixed size which is not the case with plain Base58. The disadvantage is that default libraries won't work. For details, see reference C++ Base58 implementation and unofficial Python Base58 implementation.","title":"Base58 in Monero"},{"location":"cryptography/introduction/","text":"Cryptography in Monero \u00b6 Monero uses a wide variety of cryptographic primitives for various use cases. Comparing to altcoins, Monero cryptography is considered conservative, sound and robust. Comparing to Bitcoin, Monero uses much more primitives, and some of them are more advanced, especially those related to privacy and Proof of Work. Some choices are deliberately non-standard (for better or worse) - oftentimes a legacy of the CryptoNote protocol.","title":"Introduction"},{"location":"cryptography/introduction/#cryptography-in-monero","text":"Monero uses a wide variety of cryptographic primitives for various use cases. Comparing to altcoins, Monero cryptography is considered conservative, sound and robust. Comparing to Bitcoin, Monero uses much more primitives, and some of them are more advanced, especially those related to privacy and Proof of Work. Some choices are deliberately non-standard (for better or worse) - oftentimes a legacy of the CryptoNote protocol.","title":"Cryptography in Monero"},{"location":"cryptography/keccak-256/","text":"Keccak-256 Hash Function \u00b6 Monero employs Keccak as a hashing function. In most context specifically Keccak-256 is used, providing 32-byte hashes. Keccak is the leading hashing function, designed by non-NSA designers. Keccak won NIST competition to become the official SHA3. Use Cases \u00b6 Monero does not employ Keccak for Proof-of-Work. Instead, Keccak is used for: random number generator block hashing transaction hashing stealth address private key image (for double spend protection) public address checksum RingCT multisig bulletproofs ...and likely a few other things. Keccak-256 vs SHA3-256 \u00b6 SHA3-256 is Keccak-256, except NIST changed padding. For that reason original Keccak-256 gives in a different hash value than NIST SHA3-256. Monero uses original Keccak-256. The NIST standard was only published on August 2015, while Monero went live on 18 April 2014. Reference \u00b6 Keccak source code used in Monero SHA3 on Wikipedia Keccak-256 vs SHA3-256 explained on Ethereum stackexchange Online tool to calculate Keccak-256 and SHA3-256","title":"Keccak-256"},{"location":"cryptography/keccak-256/#keccak-256-hash-function","text":"Monero employs Keccak as a hashing function. In most context specifically Keccak-256 is used, providing 32-byte hashes. Keccak is the leading hashing function, designed by non-NSA designers. Keccak won NIST competition to become the official SHA3.","title":"Keccak-256 Hash Function"},{"location":"cryptography/keccak-256/#use-cases","text":"Monero does not employ Keccak for Proof-of-Work. Instead, Keccak is used for: random number generator block hashing transaction hashing stealth address private key image (for double spend protection) public address checksum RingCT multisig bulletproofs ...and likely a few other things.","title":"Use Cases"},{"location":"cryptography/keccak-256/#keccak-256-vs-sha3-256","text":"SHA3-256 is Keccak-256, except NIST changed padding. For that reason original Keccak-256 gives in a different hash value than NIST SHA3-256. Monero uses original Keccak-256. The NIST standard was only published on August 2015, while Monero went live on 18 April 2014.","title":"Keccak-256 vs SHA3-256"},{"location":"cryptography/keccak-256/#reference","text":"Keccak source code used in Monero SHA3 on Wikipedia Keccak-256 vs SHA3-256 explained on Ethereum stackexchange Online tool to calculate Keccak-256 and SHA3-256","title":"Reference"},{"location":"cryptography/pedersen-commitment/","text":"Pedersen Commitment \u00b6 https://www.reddit.com/r/Monero/comments/9ed7vb/pedersen_commitment/ https://monero.stackexchange.com/questions/10177/who-generates-parameters-g-h-for-pedersen-commitment-in-monero","title":"Pedersen Commitment | Monero Documentation"},{"location":"cryptography/pedersen-commitment/#pedersen-commitment","text":"https://www.reddit.com/r/Monero/comments/9ed7vb/pedersen_commitment/ https://monero.stackexchange.com/questions/10177/who-generates-parameters-g-h-for-pedersen-commitment-in-monero","title":"Pedersen Commitment"},{"location":"cryptography/prng/","text":"Monero Pseudorandom Number Generator \u00b6 Monero uses PRNG based on the Keccak hashing function. Basically, output of the previous hashing round is input for the next one. The initial seed comes from entropy sources provided by operating system. On Linux and MacOS the seed comes from /dev/urandom . On Windows the WinAPI CryptGenRandom call is used for seeding. There is no reseeding. Caveats \u00b6 This concerns the reference C++ implementation of Monero. Please note there are many alternative implementations of private key generation, including JavaScript, Python, Android/Java. These should be researched case by case for correctness. In Monero source code you can also find libsodium based random bytes generator. It is part of the embedded library and apparently is not used in actual Monero code. Reference \u00b6 Source code StackExchange answer","title":"PRNG"},{"location":"cryptography/prng/#monero-pseudorandom-number-generator","text":"Monero uses PRNG based on the Keccak hashing function. Basically, output of the previous hashing round is input for the next one. The initial seed comes from entropy sources provided by operating system. On Linux and MacOS the seed comes from /dev/urandom . On Windows the WinAPI CryptGenRandom call is used for seeding. There is no reseeding.","title":"Monero Pseudorandom Number Generator"},{"location":"cryptography/prng/#caveats","text":"This concerns the reference C++ implementation of Monero. Please note there are many alternative implementations of private key generation, including JavaScript, Python, Android/Java. These should be researched case by case for correctness. In Monero source code you can also find libsodium based random bytes generator. It is part of the embedded library and apparently is not used in actual Monero code.","title":"Caveats"},{"location":"cryptography/prng/#reference","text":"Source code StackExchange answer","title":"Reference"},{"location":"cryptography/asymmetric/edwards25519/","text":"Edwards25519 Elliptic Curve \u00b6 Note Author is nowhere close to being a cryptographer. Be sceptical on accuracy. Note This article is only about the underlying curve. Public key derivation and signing algorithm will be treated separately. Monero employs edwards25519 elliptic curve as a basis for its key pair generation. The curve comes from the Ed25519 signature scheme. While Monero takes the curve unchanged, it does not exactly follow rest of the Ed25519. The edwards25519 curve is birationally equivalent to Curve25519 . Definition \u00b6 This is the standard edwards25519 curve definition, no Monero specific stuff here, except the naming convention. The convention comes from the CryptoNote whitepaper and is widely used in Monero literature. Curve equation \u00b6 \u2212x^2 + y^2 = 1 \u2212 (121665/121666) * x^2 * y^2 Note: curve is in two dimensions (nothing fancy, like all the curves is high school) curve is mirrored below y axis due to y^2 part of the equation (not a polynomial) Base point: G \u00b6 The base point is a specific point on the curve. It is used as a basis for further calculations. It is an arbitrary choice by the curve authors, just to standardize the scheme. Note that it is enough to specify the y value and the sign of the x value. That's because the specific x can be calculated from the curve equation. G = (x, 4/5) # take the point with the positive x # The hex representation of the base point 5866666666666666666666666666666666666666666666666666666666666666 Prime order of the base point: l \u00b6 In layment terms, the \"canvas\" where the curve is drawn is assumed to have a finite \"resolution\", so point coordinates must \"wrap around\" at some point. This is achieved by modulo the l value (lowercase L). In other words, the l defines the maximum scalar we can use. l = 2^252 + 27742317777372353535851937790883648493 # => 7237005577332262213973186563042994240857116359379907606001950938285454250989 The l is a prime number specified by the curve authors. In practice this is the private key's strength. Total number of points on the curve \u00b6 The total number of points on the curve is also a prime number: q = 2^255 - 19 In practice not all points are \"useful\" and so the private key strength is limited to l describe above. Implementation \u00b6 Monero uses (apparently modified) Ref10 implementation by Daniel J. Bernstein. Reference \u00b6 A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography RFC 8032 defining EdDSA Understanding Monero Cryptography - excellent writeup by Luigi StackOverflow answer Python implementation - not the reference one but easier to understand Encoding point to hex EdDSA on Wikipedia","title":"Edwards25519 curve"},{"location":"cryptography/asymmetric/edwards25519/#edwards25519-elliptic-curve","text":"Note Author is nowhere close to being a cryptographer. Be sceptical on accuracy. Note This article is only about the underlying curve. Public key derivation and signing algorithm will be treated separately. Monero employs edwards25519 elliptic curve as a basis for its key pair generation. The curve comes from the Ed25519 signature scheme. While Monero takes the curve unchanged, it does not exactly follow rest of the Ed25519. The edwards25519 curve is birationally equivalent to Curve25519 .","title":"Edwards25519 Elliptic Curve"},{"location":"cryptography/asymmetric/edwards25519/#definition","text":"This is the standard edwards25519 curve definition, no Monero specific stuff here, except the naming convention. The convention comes from the CryptoNote whitepaper and is widely used in Monero literature.","title":"Definition"},{"location":"cryptography/asymmetric/edwards25519/#curve-equation","text":"\u2212x^2 + y^2 = 1 \u2212 (121665/121666) * x^2 * y^2 Note: curve is in two dimensions (nothing fancy, like all the curves is high school) curve is mirrored below y axis due to y^2 part of the equation (not a polynomial)","title":"Curve equation"},{"location":"cryptography/asymmetric/edwards25519/#base-point-g","text":"The base point is a specific point on the curve. It is used as a basis for further calculations. It is an arbitrary choice by the curve authors, just to standardize the scheme. Note that it is enough to specify the y value and the sign of the x value. That's because the specific x can be calculated from the curve equation. G = (x, 4/5) # take the point with the positive x # The hex representation of the base point 5866666666666666666666666666666666666666666666666666666666666666","title":"Base point: G"},{"location":"cryptography/asymmetric/edwards25519/#prime-order-of-the-base-point-l","text":"In layment terms, the \"canvas\" where the curve is drawn is assumed to have a finite \"resolution\", so point coordinates must \"wrap around\" at some point. This is achieved by modulo the l value (lowercase L). In other words, the l defines the maximum scalar we can use. l = 2^252 + 27742317777372353535851937790883648493 # => 7237005577332262213973186563042994240857116359379907606001950938285454250989 The l is a prime number specified by the curve authors. In practice this is the private key's strength.","title":"Prime order of the base point: l"},{"location":"cryptography/asymmetric/edwards25519/#total-number-of-points-on-the-curve","text":"The total number of points on the curve is also a prime number: q = 2^255 - 19 In practice not all points are \"useful\" and so the private key strength is limited to l describe above.","title":"Total number of points on the curve"},{"location":"cryptography/asymmetric/edwards25519/#implementation","text":"Monero uses (apparently modified) Ref10 implementation by Daniel J. Bernstein.","title":"Implementation"},{"location":"cryptography/asymmetric/edwards25519/#reference","text":"A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography RFC 8032 defining EdDSA Understanding Monero Cryptography - excellent writeup by Luigi StackOverflow answer Python implementation - not the reference one but easier to understand Encoding point to hex EdDSA on Wikipedia","title":"Reference"},{"location":"cryptography/asymmetric/introduction/","text":"Asymmetric Cryptography in Monero \u00b6 Note Author is nowhere close to being a cryptographer. Be sceptical on accuracy. Before we get to Monero specific stuff, a little bit of context. We are talking asymmetric cryptography here. The \"asymmetric\" simply means the are two keys: the private key (used primarily for signing data and for decrypting data) the public key (used primarily for signature verification and encrypting data) This is in contrast to symmetric cryptography which uses a single key. This key is a secret shared among the parties. Historically, asymmetric cryptography was based on the problem of factorization of a very large integers back into prime numbers (which is practically impossible for large enough integers). Recently, asymmetric cryptography is based on a mathematical notion of elliptic curves. Edwards25519 is a specific, well researched and standardized elliptic curve used in Monero.","title":"Introduction"},{"location":"cryptography/asymmetric/introduction/#asymmetric-cryptography-in-monero","text":"Note Author is nowhere close to being a cryptographer. Be sceptical on accuracy. Before we get to Monero specific stuff, a little bit of context. We are talking asymmetric cryptography here. The \"asymmetric\" simply means the are two keys: the private key (used primarily for signing data and for decrypting data) the public key (used primarily for signature verification and encrypting data) This is in contrast to symmetric cryptography which uses a single key. This key is a secret shared among the parties. Historically, asymmetric cryptography was based on the problem of factorization of a very large integers back into prime numbers (which is practically impossible for large enough integers). Recently, asymmetric cryptography is based on a mathematical notion of elliptic curves. Edwards25519 is a specific, well researched and standardized elliptic curve used in Monero.","title":"Asymmetric Cryptography in Monero"},{"location":"cryptography/asymmetric/key-image/","text":"Monero Private Key Image \u00b6 Note Author is nowhere close to being a cryptographer. Be sceptical on accuracy. Private key image serves to detect double spending attempts. In Monero funds are always sent to a one-time public key P . Related one-time private key x is specific to unspent output. As output can be spent only once (in whole), the related private key can be used only once as well. Thus, specific private key image I being present on the blockchain means that related output was already spent, and subsequent attempts must not be allowed. This whole scheme is necessary because Monero uses Ring Signatures which make it impossible to know whom exactly signed the transaction. This is why a simple Bitcoin-like double spending check wouldn't work here. Definition \u00b6 I = x*Hp(P) Where: I - private key image (or \"key image\" for short) x - one-time private key used to unlock an unspent output P - one-time public key of an unspent output Hp() - hash function accepting an EC point as an argument The P comes from this: P = xG Where G is the edwards25519 base point. Substitute P with xG and we get: I = x*Hp(xG) The key image I is a one-way function of the private key x . Reference \u00b6 StackExchange answer Another SE answer Critical bug regarding key image verification that was once present in Monero","title":"Key image"},{"location":"cryptography/asymmetric/key-image/#monero-private-key-image","text":"Note Author is nowhere close to being a cryptographer. Be sceptical on accuracy. Private key image serves to detect double spending attempts. In Monero funds are always sent to a one-time public key P . Related one-time private key x is specific to unspent output. As output can be spent only once (in whole), the related private key can be used only once as well. Thus, specific private key image I being present on the blockchain means that related output was already spent, and subsequent attempts must not be allowed. This whole scheme is necessary because Monero uses Ring Signatures which make it impossible to know whom exactly signed the transaction. This is why a simple Bitcoin-like double spending check wouldn't work here.","title":"Monero Private Key Image"},{"location":"cryptography/asymmetric/key-image/#definition","text":"I = x*Hp(P) Where: I - private key image (or \"key image\" for short) x - one-time private key used to unlock an unspent output P - one-time public key of an unspent output Hp() - hash function accepting an EC point as an argument The P comes from this: P = xG Where G is the edwards25519 base point. Substitute P with xG and we get: I = x*Hp(xG) The key image I is a one-way function of the private key x .","title":"Definition"},{"location":"cryptography/asymmetric/key-image/#reference","text":"StackExchange answer Another SE answer Critical bug regarding key image verification that was once present in Monero","title":"Reference"},{"location":"cryptography/asymmetric/private-key/","text":"Private Keys in Monero \u00b6 Note Author is nowhere close to being a cryptographer. Be sceptical on accuracy. In Monero, the root private key is generated randomly . Other private keys are derived deterministically from the root private key. Private key must be kept secret. Private key is a large integer impossible to guess, like: 108555083659983933209597798445644913612440610624038028786991485007418559037440 Private key is 256 bits long. Private key is a scalar , meaning it is a single value. In equations scalars are represented by lowercase letters . Relation to Ed25519 \u00b6 Being simply a random integer, private key is not specific to any particular asymmetric cryptography scheme. In context of Monero EC cryptography the private key is a number the base point G is multiplied by. The result of the multiplication is the public key P (another point on the curve). Multiplication of a point by a number has a very special definition in EC cryptography. See this this guide for details. Key strength \u00b6 Before deriving the public key, private key is subject to modulo l , where l is the maximum scalar allowed by the edwards25519 curve . The l is on the order of 2^252, so the effective key strength is technically 252 bits, not 256 bits. This is standard for EC cryptography and is more of a cosmetic nuance than any concern. Encoding \u00b6 In user-facing contexts, the private key integer is: Taken modulo l to avoid malleability Put as array of 32 bytes in a little-endian direction (the first byte is the least significant) Converted to hexadecimal form, like: b3588a87056fb21dc4d052d59e83b54293882e646b543c29478e4cf45c28a402 Private spend key \u00b6 Private spend key is used to spend moneros. More specifically, it is used to build one-time private keys which allow to spend related outputs. Private view key \u00b6 Private view key is used to recognize your incoming transactions on the otherwise opaque blockchain. One-time private keys \u00b6 One-time private key like construct is used in stealth addresses .","title":"Private keys"},{"location":"cryptography/asymmetric/private-key/#private-keys-in-monero","text":"Note Author is nowhere close to being a cryptographer. Be sceptical on accuracy. In Monero, the root private key is generated randomly . Other private keys are derived deterministically from the root private key. Private key must be kept secret. Private key is a large integer impossible to guess, like: 108555083659983933209597798445644913612440610624038028786991485007418559037440 Private key is 256 bits long. Private key is a scalar , meaning it is a single value. In equations scalars are represented by lowercase letters .","title":"Private Keys in Monero"},{"location":"cryptography/asymmetric/private-key/#relation-to-ed25519","text":"Being simply a random integer, private key is not specific to any particular asymmetric cryptography scheme. In context of Monero EC cryptography the private key is a number the base point G is multiplied by. The result of the multiplication is the public key P (another point on the curve). Multiplication of a point by a number has a very special definition in EC cryptography. See this this guide for details.","title":"Relation to Ed25519"},{"location":"cryptography/asymmetric/private-key/#key-strength","text":"Before deriving the public key, private key is subject to modulo l , where l is the maximum scalar allowed by the edwards25519 curve . The l is on the order of 2^252, so the effective key strength is technically 252 bits, not 256 bits. This is standard for EC cryptography and is more of a cosmetic nuance than any concern.","title":"Key strength"},{"location":"cryptography/asymmetric/private-key/#encoding","text":"In user-facing contexts, the private key integer is: Taken modulo l to avoid malleability Put as array of 32 bytes in a little-endian direction (the first byte is the least significant) Converted to hexadecimal form, like: b3588a87056fb21dc4d052d59e83b54293882e646b543c29478e4cf45c28a402","title":"Encoding"},{"location":"cryptography/asymmetric/private-key/#private-spend-key","text":"Private spend key is used to spend moneros. More specifically, it is used to build one-time private keys which allow to spend related outputs.","title":"Private spend key"},{"location":"cryptography/asymmetric/private-key/#private-view-key","text":"Private view key is used to recognize your incoming transactions on the otherwise opaque blockchain.","title":"Private view key"},{"location":"cryptography/asymmetric/private-key/#one-time-private-keys","text":"One-time private key like construct is used in stealth addresses .","title":"One-time private keys"},{"location":"cryptography/asymmetric/public-key/","text":"Public Keys in Monero \u00b6 Note Author is nowhere close to being a cryptographer. Be sceptical on accuracy. Public key is deterministically derived from private key based on edwards25519 curve with a little Monero-specific twist. Public key is meant to be shared. Assuming correct implementation, it is not practically possible to recover private key from public key. Public key is a point (x,y) on the elliptic curve. In equations points are represented by uppercase letters . In user-facing contexts, public key is encoded in a little-endian hexadecimal form, like: 016a941812293cf9a86071060fb090ab38d67945e659968cb8cf30e1bc725683 Deriving public key \u00b6 Say: P is a public key x is a private key G is a \"base point\"; this is simply a constant specific to edwards25519 ; this point lies on the elliptic curve Then: P = xG The public key is simply the base point (G) multiplied by the private key (x). Multiplying the point is adding the point to itself a number of times. However, the addition is not a simple vector addition. It has a very specific definition nicely described in this article . What is important is that result of addition is always a point on the curve. For example, G + G is another point on the curve. Use cases \u00b6 Monero address is composed of public spend key and public view key. These keys are used to build stealth addresses to receive payments.","title":"Public keys"},{"location":"cryptography/asymmetric/public-key/#public-keys-in-monero","text":"Note Author is nowhere close to being a cryptographer. Be sceptical on accuracy. Public key is deterministically derived from private key based on edwards25519 curve with a little Monero-specific twist. Public key is meant to be shared. Assuming correct implementation, it is not practically possible to recover private key from public key. Public key is a point (x,y) on the elliptic curve. In equations points are represented by uppercase letters . In user-facing contexts, public key is encoded in a little-endian hexadecimal form, like: 016a941812293cf9a86071060fb090ab38d67945e659968cb8cf30e1bc725683","title":"Public Keys in Monero"},{"location":"cryptography/asymmetric/public-key/#deriving-public-key","text":"Say: P is a public key x is a private key G is a \"base point\"; this is simply a constant specific to edwards25519 ; this point lies on the elliptic curve Then: P = xG The public key is simply the base point (G) multiplied by the private key (x). Multiplying the point is adding the point to itself a number of times. However, the addition is not a simple vector addition. It has a very specific definition nicely described in this article . What is important is that result of addition is always a point on the curve. For example, G + G is another point on the curve.","title":"Deriving public key"},{"location":"cryptography/asymmetric/public-key/#use-cases","text":"Monero address is composed of public spend key and public view key. These keys are used to build stealth addresses to receive payments.","title":"Use cases"},{"location":"infrastructure/monero-pulse/","text":"MoneroPulse \u00b6 What is MoneroPulse? \u00b6 MoneroPulse is infrastructure for emergency checkpointing the blockchain. It aims to mitigate chain-splits resulting from consensus bugs (like this one from 2014 ). Effectively, MoneroPulse operators can publish which fork they consider the valid one. Technically, the \"checkpoint\" they publish is a block hash and the block height. By default, Monero full node will simply warn users when MoneroPulse checkpoint does not match the fork it is on. The error will be present in the log and on the console in red. Users are free to discard it. Ideally though, users should consult community on what is going on, and make educated decission on whether to follow the checkpoint-compatible fork or the default fork. Users can also set auto-enforcing the checkpoints via --enforce-dns-checkpointing option to monerod . In case of mismatch, monerod will rollback the local blockchain by a few blocks. Eventually, the alternative (\"fixed\") fork will get heavier and the node will follow it, leaving the \"invalid\" fork behind. This option is recommended for unattended full nodes. Summing up, MoneroPulse is emergency checkpointing mechanism. It is opt-in for the users. MoneroPulse is DNS based \u00b6 The ckeckpoints are stored as DNS TXT records for domains owned by MoneroPulse operators. To get the idea you can access the checkpoints manually with any DNS client: Try: dig -t txt checkpoints.moneropulse.net +dnssec Result: (cut) ;; ANSWER SECTION: checkpoints.moneropulse.net. 299 IN TXT \"1288616:875ac1bc7aa6c5eedc5410abb9c694034f9e7f79dce4c60698baf37009cb6365\" checkpoints.moneropulse.net. 299 IN TXT \"375000:c80c23e387585e12ffb6649d678e9ba328181797b9583a6d8911b77e25375737\" checkpoints.moneropulse.net. 299 IN TXT \"325000:4260d56368267bc2a70dd58d73c5ecf23b4e4d96e63c29a868e4a679b0741c7f\" checkpoints.moneropulse.net. 299 IN TXT \"233000:4f69bec2af6c0852412bdd10c19e6af10c8d738fe2618b5511a98efd03ab477e\" checkpoints.moneropulse.net. 299 IN TXT \"450000:4d098b511ca97723e81737c448343cfd4e6dadb3d8a0e757c6e4d595e6e48357\" checkpoints.moneropulse.net. 299 IN TXT \"250000:f59d31839bd909ec8830b4f7f66ff213f0bd006334c8523daee452725e5c7a79\" checkpoints.moneropulse.net. 299 IN TXT \"550000:c2e80a636438bd9f7a7ab432a6ad297e35540d80ff5b868bca098124cad2ff8c\" checkpoints.moneropulse.net. 299 IN TXT \"650000:1d567f2b491324375a825895c5e7b52857b38e4fed0e42c40909c2d52240b4e0\" checkpoints.moneropulse.net. 299 IN TXT \"800000:2ced10aa85357ab6c14bb12b6b56d1dde28940820dda30911b73a5cc9a301760\" checkpoints.moneropulse.net. 299 IN TXT \"850000:00e2b557dde9fd4a9e2e3dd7ddac962f5ca475eb1095bc50aa757fd1218ab0a5\" checkpoints.moneropulse.net. 299 IN TXT \"900000:d9958d0e7dcf91a5a7b11de225927bf7efc6eb26240315ce12372be902cc1337\" checkpoints.moneropulse.net. 299 IN TXT \"913193:5292d5d56f6ba4de33a58d9a34d263e2cb3c6fee0aed2286fd4ac7f36d53c85f\" checkpoints.moneropulse.net. 299 IN TXT \"913269:f8302e6b8ba1c49aad9a854b8d6c79d8272c6239dcbba5a75ed0784c1d4f56a1\" checkpoints.moneropulse.net. 299 IN TXT \"350000:74da79f6a136969abd6364bd3d37af273c408d6471e8ab598e80569b42415f86\" checkpoints.moneropulse.net. 299 IN TXT \"400000:1b2b0e7a30e59691491529a3d506d1ba3d6052d0f6b52198b7330b28a6f1b6ac\" checkpoints.moneropulse.net. 299 IN TXT \"500000:2428f0dbe49796be05ed81b347f53e1f7f44aed0abf641446ec2b94cae066b02\" checkpoints.moneropulse.net. 299 IN TXT \"600000:f5828ebf7d7d1cb61762c4dfe3ccf4ecab2e1aad23e8113668d981713b7a54c5\" checkpoints.moneropulse.net. 299 IN TXT \"700000:12be9b3d210b93f574d2526abb9c1ab2a881b479131fd0d4f7dac93875f503cd\" checkpoints.moneropulse.net. 299 IN TXT \"300000:0c1cd46df6ccff90ec4ab493281f2583c344cd62216c427628990fe9db1bb8b6\" checkpoints.moneropulse.net. 299 IN RRSIG TXT 13 3 300 20180922151845 20180920131845 35273 moneropulse.net. 8CyqtsM2f9o6OHZYqtGPVf+8gcFM+eUyoMi29LlkcLtK1AXbZlKqCcdN NvdvB+4OzepmpTanSc+TbLWbz/sIzA== Please note the DNSSEC signature entry at the end. The checkpoints are mirrored on several DNS servers: Mainnet: checkpoints.moneropulse.se checkpoints.moneropulse.org checkpoints.moneropulse.net checkpoints.moneropulse.co Stagenet: stagenetpoints.moneropulse.se stagenetpoints.moneropulse.org stagenetpoints.moneropulse.net stagenetpoints.moneropulse.co Testnet: testpoints.moneropulse.se testpoints.moneropulse.org testpoints.moneropulse.net testpoints.moneropulse.co MoneroPulse as attack vector \u00b6 It is worth noting that MoneroPulse does not produce blocks and cannot split the chain on its own. It only suggests the valid fork. Should MoneroPulse got entirely compromised, attacker could stop all auto-enforcing nodes from advancing, by feeding them with the fake checkpoint. This is partially mitigated by DNSSEC and by operating multiple domains. Monero expects checkpoints are consistent across domains. Thus, compromising a single domain or registrar should not lead to any disruption. MoneroPulse also increases the say of its operators in case of possible contentious hard forks. While well intended, this effectively centralizes more power in hands of core developers, or whomever is at the time running MoneroPulse infrastructure. Who are MoneroPulse operators? \u00b6 MoneroPulse is operated by selected core developers. Fixing \"WARNING: no two valid MoneroPulse DNS checkpoint records were received\" \u00b6 This means DNS server you are using does not ackonwledge the +dnssec flag necessary for securely query for checkpoints. By default, your operating system will use DNS server provided by your Internet Service Provider. To fix this warning, change your DNS server either system-wide in your network configuration, or specifically for monerod . Many people find Google's or Cloudflare's DNS servers superior to those offered by their ISPs. Using Google DNS: DNS_PUBLIC=tcp://8.8.8.8 ./monerod Using Cloudflare DNS: DNS_PUBLIC=tcp://1.1.1.1 ./monerod Reference \u00b6 StackExchange answer Reddit answer Monero source code","title":"MoneroPulse"},{"location":"infrastructure/monero-pulse/#moneropulse","text":"","title":"MoneroPulse"},{"location":"infrastructure/monero-pulse/#what-is-moneropulse","text":"MoneroPulse is infrastructure for emergency checkpointing the blockchain. It aims to mitigate chain-splits resulting from consensus bugs (like this one from 2014 ). Effectively, MoneroPulse operators can publish which fork they consider the valid one. Technically, the \"checkpoint\" they publish is a block hash and the block height. By default, Monero full node will simply warn users when MoneroPulse checkpoint does not match the fork it is on. The error will be present in the log and on the console in red. Users are free to discard it. Ideally though, users should consult community on what is going on, and make educated decission on whether to follow the checkpoint-compatible fork or the default fork. Users can also set auto-enforcing the checkpoints via --enforce-dns-checkpointing option to monerod . In case of mismatch, monerod will rollback the local blockchain by a few blocks. Eventually, the alternative (\"fixed\") fork will get heavier and the node will follow it, leaving the \"invalid\" fork behind. This option is recommended for unattended full nodes. Summing up, MoneroPulse is emergency checkpointing mechanism. It is opt-in for the users.","title":"What is MoneroPulse?"},{"location":"infrastructure/monero-pulse/#moneropulse-is-dns-based","text":"The ckeckpoints are stored as DNS TXT records for domains owned by MoneroPulse operators. To get the idea you can access the checkpoints manually with any DNS client: Try: dig -t txt checkpoints.moneropulse.net +dnssec Result: (cut) ;; ANSWER SECTION: checkpoints.moneropulse.net. 299 IN TXT \"1288616:875ac1bc7aa6c5eedc5410abb9c694034f9e7f79dce4c60698baf37009cb6365\" checkpoints.moneropulse.net. 299 IN TXT \"375000:c80c23e387585e12ffb6649d678e9ba328181797b9583a6d8911b77e25375737\" checkpoints.moneropulse.net. 299 IN TXT \"325000:4260d56368267bc2a70dd58d73c5ecf23b4e4d96e63c29a868e4a679b0741c7f\" checkpoints.moneropulse.net. 299 IN TXT \"233000:4f69bec2af6c0852412bdd10c19e6af10c8d738fe2618b5511a98efd03ab477e\" checkpoints.moneropulse.net. 299 IN TXT \"450000:4d098b511ca97723e81737c448343cfd4e6dadb3d8a0e757c6e4d595e6e48357\" checkpoints.moneropulse.net. 299 IN TXT \"250000:f59d31839bd909ec8830b4f7f66ff213f0bd006334c8523daee452725e5c7a79\" checkpoints.moneropulse.net. 299 IN TXT \"550000:c2e80a636438bd9f7a7ab432a6ad297e35540d80ff5b868bca098124cad2ff8c\" checkpoints.moneropulse.net. 299 IN TXT \"650000:1d567f2b491324375a825895c5e7b52857b38e4fed0e42c40909c2d52240b4e0\" checkpoints.moneropulse.net. 299 IN TXT \"800000:2ced10aa85357ab6c14bb12b6b56d1dde28940820dda30911b73a5cc9a301760\" checkpoints.moneropulse.net. 299 IN TXT \"850000:00e2b557dde9fd4a9e2e3dd7ddac962f5ca475eb1095bc50aa757fd1218ab0a5\" checkpoints.moneropulse.net. 299 IN TXT \"900000:d9958d0e7dcf91a5a7b11de225927bf7efc6eb26240315ce12372be902cc1337\" checkpoints.moneropulse.net. 299 IN TXT \"913193:5292d5d56f6ba4de33a58d9a34d263e2cb3c6fee0aed2286fd4ac7f36d53c85f\" checkpoints.moneropulse.net. 299 IN TXT \"913269:f8302e6b8ba1c49aad9a854b8d6c79d8272c6239dcbba5a75ed0784c1d4f56a1\" checkpoints.moneropulse.net. 299 IN TXT \"350000:74da79f6a136969abd6364bd3d37af273c408d6471e8ab598e80569b42415f86\" checkpoints.moneropulse.net. 299 IN TXT \"400000:1b2b0e7a30e59691491529a3d506d1ba3d6052d0f6b52198b7330b28a6f1b6ac\" checkpoints.moneropulse.net. 299 IN TXT \"500000:2428f0dbe49796be05ed81b347f53e1f7f44aed0abf641446ec2b94cae066b02\" checkpoints.moneropulse.net. 299 IN TXT \"600000:f5828ebf7d7d1cb61762c4dfe3ccf4ecab2e1aad23e8113668d981713b7a54c5\" checkpoints.moneropulse.net. 299 IN TXT \"700000:12be9b3d210b93f574d2526abb9c1ab2a881b479131fd0d4f7dac93875f503cd\" checkpoints.moneropulse.net. 299 IN TXT \"300000:0c1cd46df6ccff90ec4ab493281f2583c344cd62216c427628990fe9db1bb8b6\" checkpoints.moneropulse.net. 299 IN RRSIG TXT 13 3 300 20180922151845 20180920131845 35273 moneropulse.net. 8CyqtsM2f9o6OHZYqtGPVf+8gcFM+eUyoMi29LlkcLtK1AXbZlKqCcdN NvdvB+4OzepmpTanSc+TbLWbz/sIzA== Please note the DNSSEC signature entry at the end. The checkpoints are mirrored on several DNS servers: Mainnet: checkpoints.moneropulse.se checkpoints.moneropulse.org checkpoints.moneropulse.net checkpoints.moneropulse.co Stagenet: stagenetpoints.moneropulse.se stagenetpoints.moneropulse.org stagenetpoints.moneropulse.net stagenetpoints.moneropulse.co Testnet: testpoints.moneropulse.se testpoints.moneropulse.org testpoints.moneropulse.net testpoints.moneropulse.co","title":"MoneroPulse is DNS based"},{"location":"infrastructure/monero-pulse/#moneropulse-as-attack-vector","text":"It is worth noting that MoneroPulse does not produce blocks and cannot split the chain on its own. It only suggests the valid fork. Should MoneroPulse got entirely compromised, attacker could stop all auto-enforcing nodes from advancing, by feeding them with the fake checkpoint. This is partially mitigated by DNSSEC and by operating multiple domains. Monero expects checkpoints are consistent across domains. Thus, compromising a single domain or registrar should not lead to any disruption. MoneroPulse also increases the say of its operators in case of possible contentious hard forks. While well intended, this effectively centralizes more power in hands of core developers, or whomever is at the time running MoneroPulse infrastructure.","title":"MoneroPulse as attack vector"},{"location":"infrastructure/monero-pulse/#who-are-moneropulse-operators","text":"MoneroPulse is operated by selected core developers.","title":"Who are MoneroPulse operators?"},{"location":"infrastructure/monero-pulse/#fixing-warning-no-two-valid-moneropulse-dns-checkpoint-records-were-received","text":"This means DNS server you are using does not ackonwledge the +dnssec flag necessary for securely query for checkpoints. By default, your operating system will use DNS server provided by your Internet Service Provider. To fix this warning, change your DNS server either system-wide in your network configuration, or specifically for monerod . Many people find Google's or Cloudflare's DNS servers superior to those offered by their ISPs. Using Google DNS: DNS_PUBLIC=tcp://8.8.8.8 ./monerod Using Cloudflare DNS: DNS_PUBLIC=tcp://1.1.1.1 ./monerod","title":"Fixing \"WARNING: no two valid MoneroPulse DNS checkpoint records were received\""},{"location":"infrastructure/monero-pulse/#reference","text":"StackExchange answer Reddit answer Monero source code","title":"Reference"},{"location":"infrastructure/networks/","text":"Networks \u00b6 Monero offers three separate networks and blockchains: mainnet , stagenet and testnet . Every blockchain has its own genesis block and is entirely seperate from others. Also, corresponding p2p networks are separate. Mainnet \u00b6 Mainnet is the \"production\" network and blockchain. Mainnet is the only blockchain where XMR units have value. Mainnet is what people mean by default. Default TCP ports (listening): 18080 - p2p network 18081 - JSON-RPC server 18082 - ZMQ server Stagenet \u00b6 Stagenet is what you need to learn Monero safely. Stagenet is technically equivalent to mainnet, both in terms of features and consensus rules. Similar to mainnet, use the latest official Monero release to be compatible with stagenet. To get started: Connect your GUI or CLI to stagenet open node monero-stagenet.exan.tech:38081 Get free XMR from stagenet faucet Check the stagenet block explorer Default TCP ports (listening): 38080 - p2p network 38081 - JSON-RPC server 38082 - ZMQ server Stagenet was introduced in March 2018 as part of Monero 0.12.0.0. Testnet \u00b6 As a normal user, use stagenet instead. Testnet is for developers. Testnet is the \"experimental\" network and blockchain where things get released long before mainnet. Testnet forks early and often. Most of the time you need to compile Monero from source to be compatible with testnet. Otherwise you will get stuck on the old not-forked version. To get started: Build Monero from source Connect your GUI or CLI to testnet open node monero-testnet.exan.tech:28081 Get free XMR from testnet faucet Check the testnet block explorer Default TCP ports (listening): 28080 - p2p network 28081 - JSON-RPC server 28082 - ZMQ server Private Testnet \u00b6 You can also create your private version of the testnet. Private testnet gives more flexibility to arange for specific situations for developers. Check the private testnet guide . Why stagenet and testnet coins have no value? \u00b6 If mainnet and stagenet are technically equivalent then why only mainnet coins have value? This is simply the convention community embraced. Value only comes from a shared believe that mainnet coins will be accepted by other people in the future.","title":"Mainnet, stagenet, testnet"},{"location":"infrastructure/networks/#networks","text":"Monero offers three separate networks and blockchains: mainnet , stagenet and testnet . Every blockchain has its own genesis block and is entirely seperate from others. Also, corresponding p2p networks are separate.","title":"Networks"},{"location":"infrastructure/networks/#mainnet","text":"Mainnet is the \"production\" network and blockchain. Mainnet is the only blockchain where XMR units have value. Mainnet is what people mean by default. Default TCP ports (listening): 18080 - p2p network 18081 - JSON-RPC server 18082 - ZMQ server","title":"Mainnet"},{"location":"infrastructure/networks/#stagenet","text":"Stagenet is what you need to learn Monero safely. Stagenet is technically equivalent to mainnet, both in terms of features and consensus rules. Similar to mainnet, use the latest official Monero release to be compatible with stagenet. To get started: Connect your GUI or CLI to stagenet open node monero-stagenet.exan.tech:38081 Get free XMR from stagenet faucet Check the stagenet block explorer Default TCP ports (listening): 38080 - p2p network 38081 - JSON-RPC server 38082 - ZMQ server Stagenet was introduced in March 2018 as part of Monero 0.12.0.0.","title":"Stagenet"},{"location":"infrastructure/networks/#testnet","text":"As a normal user, use stagenet instead. Testnet is for developers. Testnet is the \"experimental\" network and blockchain where things get released long before mainnet. Testnet forks early and often. Most of the time you need to compile Monero from source to be compatible with testnet. Otherwise you will get stuck on the old not-forked version. To get started: Build Monero from source Connect your GUI or CLI to testnet open node monero-testnet.exan.tech:28081 Get free XMR from testnet faucet Check the testnet block explorer Default TCP ports (listening): 28080 - p2p network 28081 - JSON-RPC server 28082 - ZMQ server","title":"Testnet"},{"location":"infrastructure/networks/#private-testnet","text":"You can also create your private version of the testnet. Private testnet gives more flexibility to arange for specific situations for developers. Check the private testnet guide .","title":"Private Testnet"},{"location":"infrastructure/networks/#why-stagenet-and-testnet-coins-have-no-value","text":"If mainnet and stagenet are technically equivalent then why only mainnet coins have value? This is simply the convention community embraced. Value only comes from a shared believe that mainnet coins will be accepted by other people in the future.","title":"Why stagenet and testnet coins have no value?"},{"location":"interacting/download-monero-binaries/","text":"Download Monero \u00b6 A single archive contains all you need to start using Monero (the full node and the wallet). We recommend downloading Monero binaries directly from GitHub: GUI + CLI: https://github.com/monero-project/monero-gui/releases CLI only: https://github.com/monero-project/monero/releases GUI is a graphical desktop wallet. CLI is a commandline desktop wallet. If you need more guidance check download Monero section on Monero website. It is critical to verify the signature of downloaded archive. Which version to download? \u00b6 Download the latest version matching your operating system and processor architecture. The CLI version is released earlier and is suitable for server deployments. The GUI version contains both CLI and GUI. It is preferable for end-users. All versions contain a full node and a wallet. Why prefer GitHub over getmonero.org? \u00b6 Binaries appear earlier on GitHub. On top of that, if you fail to properly verify the signature, GitHub is safer, simply because you don't need to trust a separate website to not be compromised. Obviously, you should still carefully verify the signature for each release. Signature verification is always the primary line of defense.","title":"Download"},{"location":"interacting/download-monero-binaries/#download-monero","text":"A single archive contains all you need to start using Monero (the full node and the wallet). We recommend downloading Monero binaries directly from GitHub: GUI + CLI: https://github.com/monero-project/monero-gui/releases CLI only: https://github.com/monero-project/monero/releases GUI is a graphical desktop wallet. CLI is a commandline desktop wallet. If you need more guidance check download Monero section on Monero website. It is critical to verify the signature of downloaded archive.","title":"Download Monero"},{"location":"interacting/download-monero-binaries/#which-version-to-download","text":"Download the latest version matching your operating system and processor architecture. The CLI version is released earlier and is suitable for server deployments. The GUI version contains both CLI and GUI. It is preferable for end-users. All versions contain a full node and a wallet.","title":"Which version to download?"},{"location":"interacting/download-monero-binaries/#why-prefer-github-over-getmoneroorg","text":"Binaries appear earlier on GitHub. On top of that, if you fail to properly verify the signature, GitHub is safer, simply because you don't need to trust a separate website to not be compromised. Obviously, you should still carefully verify the signature for each release. Signature verification is always the primary line of defense.","title":"Why prefer GitHub over getmonero.org?"},{"location":"interacting/monero-blockchain-export-reference/","text":"monero-blockchain-export - Reference \u00b6 Warning Nowadays, there is little usage for raw blockchain export / import. In the past the p2p blockchain download was much slower. Back than blockchain.raw file was used to speed up the process of bootstrapping a node. Overview \u00b6 The tool dumps local blockchain to raw format, known as the blockchain.raw file. This could be useful if you want to process blockchain efficiently with your custom tools, as the raw format is probably easier to work with than Monero's custom lmdb database. The tool works on your local copy of the blockchain. It does not require monerod running. Syntax \u00b6 ./monero-blockchain-export [options] Example: ./monero-blockchain-export --help Running \u00b6 Go to directory where you unpacked Monero. ./monero-blockchain-export --stagenet --output-file=/tmp/blockchain.raw Options \u00b6 Help \u00b6 Option Description --help Enlist available options. Pick network \u00b6 Option Description (missing) By default monero-blockchain-export assumes mainnet . --stagenet Export stagenet blockchain. --testnet Export testnet blockchain. Logging \u00b6 Specifying the log file path is not supported. Option Description --log-level 0-4 with 0 being minimal logging and 4 being full tracing. Defaults to 0 . These are general presets and do not directly map to severity levels. For example, even with minimal 0 , you may see some most important INFO entries. Example: ./monero-blockchain-export --log-level=1 Input \u00b6 Option Description --data-dir Full path to data directory. This is where the blockchain, log files, and p2p network memory are stored. For defaults and details see data directory . --database , --db-type The default and only valid value is lmdb . Output \u00b6 Option Description --output-file Specify output file path. The default is $DATA_DIR/export/blockchain.raw . Example: ./monero-blockchain-export --output-file=/tmp/blockchain.raw --blocksdat Output in blocks.dat format. --block-stop Only export up to this block number. By default do the full export (value 0 ). Reference \u00b6 https://github.com/monero-project/monero/tree/master/src/blockchain_utilities","title":"monero-blockchain-export"},{"location":"interacting/monero-blockchain-export-reference/#monero-blockchain-export-reference","text":"Warning Nowadays, there is little usage for raw blockchain export / import. In the past the p2p blockchain download was much slower. Back than blockchain.raw file was used to speed up the process of bootstrapping a node.","title":"monero-blockchain-export - Reference"},{"location":"interacting/monero-blockchain-export-reference/#overview","text":"The tool dumps local blockchain to raw format, known as the blockchain.raw file. This could be useful if you want to process blockchain efficiently with your custom tools, as the raw format is probably easier to work with than Monero's custom lmdb database. The tool works on your local copy of the blockchain. It does not require monerod running.","title":"Overview"},{"location":"interacting/monero-blockchain-export-reference/#syntax","text":"./monero-blockchain-export [options] Example: ./monero-blockchain-export --help","title":"Syntax"},{"location":"interacting/monero-blockchain-export-reference/#running","text":"Go to directory where you unpacked Monero. ./monero-blockchain-export --stagenet --output-file=/tmp/blockchain.raw","title":"Running"},{"location":"interacting/monero-blockchain-export-reference/#options","text":"","title":"Options"},{"location":"interacting/monero-blockchain-export-reference/#help","text":"Option Description --help Enlist available options.","title":"Help"},{"location":"interacting/monero-blockchain-export-reference/#pick-network","text":"Option Description (missing) By default monero-blockchain-export assumes mainnet . --stagenet Export stagenet blockchain. --testnet Export testnet blockchain.","title":"Pick network"},{"location":"interacting/monero-blockchain-export-reference/#logging","text":"Specifying the log file path is not supported. Option Description --log-level 0-4 with 0 being minimal logging and 4 being full tracing. Defaults to 0 . These are general presets and do not directly map to severity levels. For example, even with minimal 0 , you may see some most important INFO entries. Example: ./monero-blockchain-export --log-level=1","title":"Logging"},{"location":"interacting/monero-blockchain-export-reference/#input","text":"Option Description --data-dir Full path to data directory. This is where the blockchain, log files, and p2p network memory are stored. For defaults and details see data directory . --database , --db-type The default and only valid value is lmdb .","title":"Input"},{"location":"interacting/monero-blockchain-export-reference/#output","text":"Option Description --output-file Specify output file path. The default is $DATA_DIR/export/blockchain.raw . Example: ./monero-blockchain-export --output-file=/tmp/blockchain.raw --blocksdat Output in blocks.dat format. --block-stop Only export up to this block number. By default do the full export (value 0 ).","title":"Output"},{"location":"interacting/monero-blockchain-export-reference/#reference","text":"https://github.com/monero-project/monero/tree/master/src/blockchain_utilities","title":"Reference"},{"location":"interacting/monero-blockchain-import-reference/","text":"monero-blockchain-import - Reference \u00b6 Warning Nowadays, there is little usage for raw blockchain export/import. In the past the p2p blockchain download was much slower. Back than blockchain.raw file was used to speed up download process of bootstrapping a node. Overview \u00b6 The tool imports bootstrap file blockchain.raw to your full node. This could be useful if you want to decouple download from verification for any reason (like testing performance in isolation). In this case, you may download the blockchain.raw file from https://downloads.getmonero.org/blockchain.raw . Ideally though, you should use your own trusted blockchain.raw file that you exported earlier. Please note that importing blockchain.raw will not speed up the process over syncing up from p2p network. This is because usual bottlenecks are disk IO and verification, not the download. The tool works on your local files. It does not require monerod running. Syntax \u00b6 ./monero-blockchain-import [options] Example: ./monero-blockchain-import --help Running \u00b6 Go to directory where you unpacked Monero. ./monero-blockchain-import --stagenet --output-file=/tmp/blockchain.raw Options \u00b6 Help \u00b6 Option Description --help Enlist available options. Pick network \u00b6 Option Description (missing) By default monero-blockchain-import assumes the mainnet blockchain. --stagenet Import stagenet blockchain. --testnet Import testnet blockchain. Logging \u00b6 Specifying the log file path is not supported. Option Description --log-level 0-4 with 0 being minimal logging and 4 being full tracing. Defaults to 0 . These are general presets and do not directly map to severity levels. For example, even with minimal 0 , you may see some most important INFO entries. Example: ./monero-blockchain-import --log-level=1 Input \u00b6 Option Description --input-file Full path to raw blockchain file. The default is $DATA_DIR/export/blockchain.raw . --block-stop Only import up to this block height. By default import all blocks (value 0 ). --pop-blocks Discard specified number of blocks from the tip of the bootstrapped blockchain. By default don't discard anything (value 0 ). Output \u00b6 Option Description --data-dir Full path to data directory. This is where the blockchain, log files, and p2p network memory are stored. For defaults and details see data directory . --count-blocks Count blocks in the bootstrap file and exit. --drop-hard-fork Whether to drop hard fork data. Off by default ( 0 ). --database The only valid value seems to be lmdb (the default). Performance \u00b6 Option Description --dangerous-unverified-import The safe default is to run verification (value 0 ). You can enable --dangerous-unverified-import if you are importing from your own and trusted blockchain.raw (which we assume was already verified). The \"dangerous\" mode will greatly speed up the process. --batch Whether to save to disk on an ongoing basis (the default, value 1 ) or maybe do everything in RAM and save everything in the end (value 0 ). No batching is only effective in combination with no verification ( --dangerous-unverified-import ). See also --batch-size . --batch-size How often to save to disk expressed in number of blocks. By default save every 5000 blocks (when verifying) or every 20000 blocks (when not verifying). Big batches are faster but require more RAM. --resume Resume from current height if output database already exists (the default, value 1 ). Changing to --resume=0 doesn't change much \u2014 existing blocks are skipped pretty quickly and the process is resumed anyway. Reference \u00b6 https://github.com/monero-project/monero/tree/master/src/blockchain_utilities","title":"monero-blockchain-import"},{"location":"interacting/monero-blockchain-import-reference/#monero-blockchain-import-reference","text":"Warning Nowadays, there is little usage for raw blockchain export/import. In the past the p2p blockchain download was much slower. Back than blockchain.raw file was used to speed up download process of bootstrapping a node.","title":"monero-blockchain-import - Reference"},{"location":"interacting/monero-blockchain-import-reference/#overview","text":"The tool imports bootstrap file blockchain.raw to your full node. This could be useful if you want to decouple download from verification for any reason (like testing performance in isolation). In this case, you may download the blockchain.raw file from https://downloads.getmonero.org/blockchain.raw . Ideally though, you should use your own trusted blockchain.raw file that you exported earlier. Please note that importing blockchain.raw will not speed up the process over syncing up from p2p network. This is because usual bottlenecks are disk IO and verification, not the download. The tool works on your local files. It does not require monerod running.","title":"Overview"},{"location":"interacting/monero-blockchain-import-reference/#syntax","text":"./monero-blockchain-import [options] Example: ./monero-blockchain-import --help","title":"Syntax"},{"location":"interacting/monero-blockchain-import-reference/#running","text":"Go to directory where you unpacked Monero. ./monero-blockchain-import --stagenet --output-file=/tmp/blockchain.raw","title":"Running"},{"location":"interacting/monero-blockchain-import-reference/#options","text":"","title":"Options"},{"location":"interacting/monero-blockchain-import-reference/#help","text":"Option Description --help Enlist available options.","title":"Help"},{"location":"interacting/monero-blockchain-import-reference/#pick-network","text":"Option Description (missing) By default monero-blockchain-import assumes the mainnet blockchain. --stagenet Import stagenet blockchain. --testnet Import testnet blockchain.","title":"Pick network"},{"location":"interacting/monero-blockchain-import-reference/#logging","text":"Specifying the log file path is not supported. Option Description --log-level 0-4 with 0 being minimal logging and 4 being full tracing. Defaults to 0 . These are general presets and do not directly map to severity levels. For example, even with minimal 0 , you may see some most important INFO entries. Example: ./monero-blockchain-import --log-level=1","title":"Logging"},{"location":"interacting/monero-blockchain-import-reference/#input","text":"Option Description --input-file Full path to raw blockchain file. The default is $DATA_DIR/export/blockchain.raw . --block-stop Only import up to this block height. By default import all blocks (value 0 ). --pop-blocks Discard specified number of blocks from the tip of the bootstrapped blockchain. By default don't discard anything (value 0 ).","title":"Input"},{"location":"interacting/monero-blockchain-import-reference/#output","text":"Option Description --data-dir Full path to data directory. This is where the blockchain, log files, and p2p network memory are stored. For defaults and details see data directory . --count-blocks Count blocks in the bootstrap file and exit. --drop-hard-fork Whether to drop hard fork data. Off by default ( 0 ). --database The only valid value seems to be lmdb (the default).","title":"Output"},{"location":"interacting/monero-blockchain-import-reference/#performance","text":"Option Description --dangerous-unverified-import The safe default is to run verification (value 0 ). You can enable --dangerous-unverified-import if you are importing from your own and trusted blockchain.raw (which we assume was already verified). The \"dangerous\" mode will greatly speed up the process. --batch Whether to save to disk on an ongoing basis (the default, value 1 ) or maybe do everything in RAM and save everything in the end (value 0 ). No batching is only effective in combination with no verification ( --dangerous-unverified-import ). See also --batch-size . --batch-size How often to save to disk expressed in number of blocks. By default save every 5000 blocks (when verifying) or every 20000 blocks (when not verifying). Big batches are faster but require more RAM. --resume Resume from current height if output database already exists (the default, value 1 ). Changing to --resume=0 doesn't change much \u2014 existing blocks are skipped pretty quickly and the process is resumed anyway.","title":"Performance"},{"location":"interacting/monero-blockchain-import-reference/#reference","text":"https://github.com/monero-project/monero/tree/master/src/blockchain_utilities","title":"Reference"},{"location":"interacting/monero-config-file/","text":"Monero Configuration File \u00b6 Applicability \u00b6 By default Monero looks for bitmonero.conf in Monero data directory . To use a specific config file add --config-file option: ./monerod --config-file=/etc/monero.conf The --config-file option is available for: monerod monero-wallet-cli monero-wallet-rpc monero-gen-trusted-multisig Syntax \u00b6 option-name=value valueless-option-name=1 for options that don't expect value # I am a comment whitespace is ignored Reference \u00b6 All command line options work as configuration file options. See monerod reference . Skip the -- from --option-name . Example: ./monerod --log-level=4 --stagenet translates to: log-level=4 stagenet=1 # use value \"1\" for Example \u00b6 # /etc/monero.conf # Data directory (blockchain db and indices) data-dir=/home/monero/.monero # Log file log-file=/var/log/monero/monero.log max-log-file-size=0 # Prevent monerod from managing the log files; we want logrotate to take care of that # P2P full node p2p-bind-ip=0.0.0.0 # Bind to all interfaces (the default) p2p-bind-port=18080 # Bind to default port # RPC open node rpc-bind-ip=0.0.0.0 # Bind to all interfaces rpc-bind-port=18081 # Bind on default port confirm-external-bind=1 # Open node (confirm) restricted-rpc=1 # Prevent unsafe RPC calls no-igd=1 # Disable UPnP port mapping # Slow but reliable db writes db-sync-mode=safe # Emergency checkpoints set by MoneroPulse operators will be enforced to workaround potential consensus bugs # Check https://monerodocs.org/infrastructure/monero-pulse/ for explanation and trade-offs enforce-dns-checkpointing=1 out-peers=64 # This will enable much faster sync and tx awareness; the default 8 is suboptimal nowadays in-peers=1024 # The default is unlimited; we prefer to put a cap on this limit-rate-up=1048576 # 1048576 kB/s == 1GB/s; a raise from default 2048 kB/s; contribute more to p2p network limit-rate-down=1048576 # 1048576 kB/s == 1GB/s; a raise from default 8192 kB/s; allow for faster initial sync","title":"Config"},{"location":"interacting/monero-config-file/#monero-configuration-file","text":"","title":"Monero Configuration File"},{"location":"interacting/monero-config-file/#applicability","text":"By default Monero looks for bitmonero.conf in Monero data directory . To use a specific config file add --config-file option: ./monerod --config-file=/etc/monero.conf The --config-file option is available for: monerod monero-wallet-cli monero-wallet-rpc monero-gen-trusted-multisig","title":"Applicability"},{"location":"interacting/monero-config-file/#syntax","text":"option-name=value valueless-option-name=1 for options that don't expect value # I am a comment whitespace is ignored","title":"Syntax"},{"location":"interacting/monero-config-file/#reference","text":"All command line options work as configuration file options. See monerod reference . Skip the -- from --option-name . Example: ./monerod --log-level=4 --stagenet translates to: log-level=4 stagenet=1 # use value \"1\" for","title":"Reference"},{"location":"interacting/monero-config-file/#example","text":"# /etc/monero.conf # Data directory (blockchain db and indices) data-dir=/home/monero/.monero # Log file log-file=/var/log/monero/monero.log max-log-file-size=0 # Prevent monerod from managing the log files; we want logrotate to take care of that # P2P full node p2p-bind-ip=0.0.0.0 # Bind to all interfaces (the default) p2p-bind-port=18080 # Bind to default port # RPC open node rpc-bind-ip=0.0.0.0 # Bind to all interfaces rpc-bind-port=18081 # Bind on default port confirm-external-bind=1 # Open node (confirm) restricted-rpc=1 # Prevent unsafe RPC calls no-igd=1 # Disable UPnP port mapping # Slow but reliable db writes db-sync-mode=safe # Emergency checkpoints set by MoneroPulse operators will be enforced to workaround potential consensus bugs # Check https://monerodocs.org/infrastructure/monero-pulse/ for explanation and trade-offs enforce-dns-checkpointing=1 out-peers=64 # This will enable much faster sync and tx awareness; the default 8 is suboptimal nowadays in-peers=1024 # The default is unlimited; we prefer to put a cap on this limit-rate-up=1048576 # 1048576 kB/s == 1GB/s; a raise from default 2048 kB/s; contribute more to p2p network limit-rate-down=1048576 # 1048576 kB/s == 1GB/s; a raise from default 8192 kB/s; allow for faster initial sync","title":"Example"},{"location":"interacting/monero-wallet-gui-reference/","text":"monero-wallet-gui - Reference \u00b6 Overview \u00b6 Desktop GUI wallet \u00b6 The \"official\" desktop wallet for Monero. Available for Linux, macOS and Windows. Wallet uses your private keys to understand your total balance, transactions history, and to facilitate creating transactions. However, wallet does not store the blockchain and does not directly participate in the p2p network. Depends on the full node \u00b6 Wallet connects to full node to scan the blockchain for your transaction outputs and to send your transactions out to the network. The full node can be either local (same computer) or remote. Normally, you run the full node on the same computer as wallet (or within your home network). Connection happens over HTTP and uses this API . Any transaction leaving the wallet is already blinded by all Monero privacy features. This means plain text HTTP communication isn't an issue on its own even if you connect to a remote node. However, connecting to a remote node has other nuanced trade-offs, which is a topic for a separate article. TODO: write an article or link the best available source. User guide PDF \u00b6 A nice PDF guide is available in the catalog you unpacked Monero. Make sure to check it out! The online living version is also available: https://github.com/monero-ecosystem/monero-GUI-guide/blob/master/monero-GUI-guide.md Syntax \u00b6 ./monero-wallet-gui [options] Example: ./monero-wallet-gui --log-file=/dev/null Running \u00b6 Go to directory where you unpacked Monero. Run the full node and wait until it syncs up with the network (may take up to a few days): ./monerod In a separate terminal window, run the wallet: ./monero-wallet-gui Options \u00b6 Option Description --help Enlists available options. --log-file Full path to the log file. Example (mind file permissions): ./monerod --log-file=/var/log/monero/mainnet/monerod.log","title":"monero-wallet-gui"},{"location":"interacting/monero-wallet-gui-reference/#monero-wallet-gui-reference","text":"","title":"monero-wallet-gui - Reference"},{"location":"interacting/monero-wallet-gui-reference/#overview","text":"","title":"Overview"},{"location":"interacting/monero-wallet-gui-reference/#desktop-gui-wallet","text":"The \"official\" desktop wallet for Monero. Available for Linux, macOS and Windows. Wallet uses your private keys to understand your total balance, transactions history, and to facilitate creating transactions. However, wallet does not store the blockchain and does not directly participate in the p2p network.","title":"Desktop GUI wallet"},{"location":"interacting/monero-wallet-gui-reference/#depends-on-the-full-node","text":"Wallet connects to full node to scan the blockchain for your transaction outputs and to send your transactions out to the network. The full node can be either local (same computer) or remote. Normally, you run the full node on the same computer as wallet (or within your home network). Connection happens over HTTP and uses this API . Any transaction leaving the wallet is already blinded by all Monero privacy features. This means plain text HTTP communication isn't an issue on its own even if you connect to a remote node. However, connecting to a remote node has other nuanced trade-offs, which is a topic for a separate article. TODO: write an article or link the best available source.","title":"Depends on the full node"},{"location":"interacting/monero-wallet-gui-reference/#user-guide-pdf","text":"A nice PDF guide is available in the catalog you unpacked Monero. Make sure to check it out! The online living version is also available: https://github.com/monero-ecosystem/monero-GUI-guide/blob/master/monero-GUI-guide.md","title":"User guide PDF"},{"location":"interacting/monero-wallet-gui-reference/#syntax","text":"./monero-wallet-gui [options] Example: ./monero-wallet-gui --log-file=/dev/null","title":"Syntax"},{"location":"interacting/monero-wallet-gui-reference/#running","text":"Go to directory where you unpacked Monero. Run the full node and wait until it syncs up with the network (may take up to a few days): ./monerod In a separate terminal window, run the wallet: ./monero-wallet-gui","title":"Running"},{"location":"interacting/monero-wallet-gui-reference/#options","text":"Option Description --help Enlists available options. --log-file Full path to the log file. Example (mind file permissions): ./monerod --log-file=/var/log/monero/mainnet/monerod.log","title":"Options"},{"location":"interacting/monerod-reference/","text":"monerod - Reference \u00b6 Overview \u00b6 Connects you to Monero network \u00b6 The Monero daemon monerod keeps your computer synced up with the Monero network. It downloads and validates the blockchain from the p2p network. Not aware of your private keys \u00b6 monerod is entirely decoupled from your wallet. monerod does not access your private keys - it is not aware of your transactions and balance. This allows you to run monerod on a separate computer or in the cloud. In fact, you can connect to a remote monerod instance provided by a semi-trusted 3rd party. Such 3rd party will not be able to steal your funds. This is very handy for learning and experimentation. However, there are privacy and reliability implications to using a remote, untrusted node. For any real business you should be running your own full node . Syntax \u00b6 ./monerod [options] [command] Options define how the daemon should be working. Their names follow the --option-name pattern. Commands give access to specific services provided by the daemon. Commands are executed against the running daemon. Their names follow the command_name pattern. Running \u00b6 Go to directory where you unpacked Monero. The stagenet is what your should be using for learning and experimentation. ./monerod --stagenet --detach # run as a daemon in background tail -f ~/.bitmonero/stagenet/bitmonero.log # watch the logs ./monerod --stagenet exit # ask daemon to exit gracefully The mainnnet is when you want to deal with the real XMR. ./monerod --detach # run as a daemon in background tail -f ~/.bitmonero/bitmonero.log # watch the logs ./monerod exit # ask daemon to exit gracefully Options \u00b6 Options define how the daemon should be working. Their names follow the --option-name pattern. The following groups are only to make reference easier to follow. The daemon itself does not group options in any way. Help and version \u00b6 Option Description --help Enlist available options. --version Show monerod version to stdout. Example: Monero 'Lithium Luna' (v0.12.3.0-release) --os-version Show build timestamp and target operating system. Example output: OS: Linux #1 SMP PREEMPT Fri Aug 24 12:48:58 UTC 2018 4.18.5-arch1-1-ARCH . Pick network \u00b6 Option Description (missing) By default monerod assumes mainnet . --stagenet Run on stagenet . Remember to run your wallet with --stagenet as well. --testnet Run on testnet . Remember to run your wallet with --testnet as well. Logging \u00b6 Option Description --log-file Full path to the log file. Example (mind file permissions): ./monerod --log-file=/var/log/monero/mainnet/monerod.log --log-level 0-4 with 0 being minimal logging and 4 being full tracing. Defaults to 0 . These are general presets and do not directly map to severity levels. For example, even with minimal 0 , you may see some most important INFO entries. Temporarily changing to 1 allows for much better understanding of how the full node operates. Example: ./monerod --log-level=1 --max-log-file-size Soft limit in bytes for the log file (=104850000 by default, which is just under 100MB). Once log file grows past that limit, monerod creates the next log file with a UTC timestamp postfix -YYYY-MM-DD-HH-MM-SS . In production deployments, you would probably prefer to use established solutions like logrotate instead. In that case, set --max-log-file-size=0 to prevent monerod from managing the log files. --max-log-files Limit on the number of log files (=50 by default). The oldest log files are removed. In production deployments, you would probably prefer to use established solutions like logrotate instead. Server \u00b6 monerod defaults are adjusted for running it occasionally on the same computer as your Monero wallet. The following options will be helpful if you intend to have an always running node \u2014 most likely on a remote server or your own separate PC. Option Description --config-file Full path to the configuration file . By default monerod looks for bitmonero.conf in Monero data directory . --data-dir Full path to data directory. This is where the blockchain, log files, and p2p network memory are stored. For defaults and details see data directory . --pidfile Full path to the PID file. Works only with --detach . Example: ./monerod --detach --pidfile=/run/monero/monerod.pid --detach Go to background (decouple from the terminal). This is useful for long-running / server scenarios. Typically, you will also want to manage monerod daemon with systemd or similar. By default monerod runs in a foreground. --non-interactive Do not require tty in a foreground mode. Helpful when running in a container. By default monerod runs in a foreground and opens stdin for reading. This breaks containerization because no tty gets assigned and monerod process crashes. You can make it run in a background with --detach but this is inconvenient in a containerized environment because the canonical usage is that the container waits on the main process to exist (forking makes things more complicated). --no-igd Disable UPnP port mapping on the router (\"Internet Gateway Device\"). Add this option to improve security if you are not behind a NAT (you can bind directly to public IP or you run through Tor). --max-txpool-weight Set maximum transactions pool size in bytes. By default 648000000 (~618MB). These are transactions pending for confirmations (not included in any block). --enforce-dns-checkpointing The emergency checkpoints set by MoneroPulse operators will be enforced. It is probably a good idea to set enforcing for unattended nodes. If encountered block hash does not match corresponding checkpoint, the local blockchain will be rolled back a few blocks, effectively blocking following what MoneroPulse operators consider invalid fork. The log entry will be produced: ERROR Local blockchain failed to pass a checkpoint, rolling back! Eventually, the alternative (\"fixed\") fork will get heavier and the node will follow it, leaving the \"invalid\" fork behind. By default checkpointing only notifies about discrepancy by producing the following log entry: ERROR WARNING: local blockchain failed to pass a MoneroPulse checkpoint, and you could be on a fork. You should either sync up from scratch, OR download a fresh blockchain bootstrap, OR enable checkpoint enforcing with the --enforce-dns-checkpointing command-line option . Reference: source code . --disable-dns-checkpoints The MoneroPulse checkpoints set by core developers will be discarded. The checkpoints are apparently still fetched though. P2P network \u00b6 The following options define how your node participates in Monero peer-to-peer network. This is for node-to-node communication. The following options do not affect wallet-to-node interface. The node and peer words are used interchangeably. Option Description --p2p-bind-ip Network interface to bind to for p2p network protocol. Default value 0.0.0.0 binds to all network interfaces. This is typically what you want. You must change this if you want to constrain binding, for example to configure connection through Tor via torsocks: DNS_PUBLIC=tcp://1.1.1.1 TORSOCKS_ALLOW_INBOUND=1 torsocks ./monerod --p2p-bind-ip 127.0.0.1\u200a--no-igd\u200a--hide-my-port --p2p-bind-port TCP port to listen for p2p network connections. Defaults to 18080 for mainnet, 28080 for testnet, and 38080 for stagenet. You normally wouldn't change that. This is helpful to run several nodes on your machine to simulate private Monero p2p network (likely using private Testnet). Example: ./monerod --p2p-bind-port=48080 --p2p-external-port TCP port to listen for p2p network connections on your router. Relevant if you are behind a NAT and still want to accept incoming connections. You must then set this to relevant port on your router. This is to let monerod know what to advertise on the network. Default is 0 . --hide-my-port monerod will still open and listen on the p2p port. However, it will not announce itself as a peer list candidate. Technically, it will return port 0 in a response to p2p handshake ( node_data.my_port = 0 in get_local_node_data function). In effect nodes you connect to won't spread your IP to other nodes. To sum up, it is not really hiding, it is more like \"do not advertise\". --seed-node Connect to a node to retrieve other nodes' addresses, and disconnect. If not specified, monerod will use hardcoded seed nodes on the first run, and peers cached on disk on subsequent runs. --add-peer Manually add node to local peer list. --add-priority-node Specify list of nodes to connect to and then attempt to keep the connection open. To add multiple nodes use the option several times. Example: ./monerod --add-priority-node=178.128.192.138:18081 --add-priority-node=144.76.202.167:18081 --add-exclusive-node Specify list of nodes to connect to only. If this option is given the options --add-priority-node and --seed-node are ignored. To add multiple nodes use the option several times. Example: ./monerod --add-exclusive-node=178.128.192.138:18081 --add-exclusive-node=144.76.202.167:18081 --out-peers Set max number of outgoing connections to other nodes. By default 8. Value -1 represents the code default. --in-peers Set max number of incoming connections (nodes actively connecting to you). By default unlimited. Value -1 represents the code default. --limit-rate-up Set outgoing data transfer limit [kB/s]. By default 2048 kB/s. Value -1 represents the code default. --limit-rate-down Set incoming data transfer limit [kB/s]. By default 8192 kB/s. Value -1 represents the code default. --limit-rate Set the same limit value for incoming and outgoing data transfer. By default ( -1 ) the individual up/down default limits will be used. It is better to use --limit-rate-up and --limit-rate-down instead to avoid confusion. --offline Do not listen for peers, nor connect to any. Useful for working with a local, archival blockchain. --allow-local-ip Allow adding local IP to peer list. Useful mostly for debug purposes when you may want to have multiple nodes on a single machine. Node RPC API \u00b6 monerod node offers powerful API. It serves 3 purposes: provides network data (stats, blocks, transactions, ...) provides local node information (peer list, hash rate if mining, ...) provides interface for wallets (send transactions, ...) This API is typically referred to as \"RPC\" because it is mostly based on JSON/RPC standard. The following options define how the API behaves. Option Description --rpc-bind-ip IP to listen on. By default 127.0.0.1 because API gives full administrative capabilities over the node. Set it to 0.0.0.0 to listen on all interfaces - but only in connection with one of *-restricted-* options and --confirm-external-bind . --rpc-bind-port TCP port to listen on. By default 18081 (mainnet), 28081 (testnet), 38081 (stagenet). --rpc-restricted-bind-port TCP port to listen on with the limited version of API. The limited API can be made public to create an Open Node. At the same time, you may firewall the full API port to still enjoy local querying and administration. --confirm-external-bind Confirm you consciously set --rpc-bind-ip to non-localhost IP and you understand the consequences. --restricted-rpc Restrict API to view only commands and do not return privacy sensitive data. Note this does not make sense with --rpc-restricted-bind-port because you would end up with two restricted APIs. --rpc-login Specify username[:password] required to connect to API. Practical usage seems limited because API communication is in plain text over HTTP. --rpc-access-control-origins Specify a comma separated list of origins to allow cross origin resource sharing. This is useful if you want to use monerod API directly from a web browser via JavaScript (say in a pure-fronted web appp scenario). With this option monerod will put proper HTTP CORS headers to its responses. You will also need to set --rpc-login if you use this option. Normally though, the API is used by backend app and this option isn't necessary. Accepting Monero \u00b6 Option Description --block-notify Run a program for each new block. The argument must be a full path . If the argument contains %s it will be replaced by the block hash. Example: ./monerod --block-notify=\"/usr/bin/echo %s\" Couple of notes: 1) Block notifications are good for immediate reaction. However, you should always assume you will miss some block notifications and you should independently poll the API to cover this up. 2) Mind blockchain reorganizations. Block notifications can revert to same and past heights. This actually happens pretty often. 3) See also --tx-notify option of monero-wallet-rpc daemon here . Performance \u00b6 These are advanced options that allow you to optimize performance of your monerod node, sometimes at the expense of reliability. Option Description --db-sync-mode Specify sync option, using format: [safe|fast|fastest]:[sync|async]:[<nblocks_per_sync>[blocks]|<nbytes_per_sync>[bytes]] The default is fast:async:250000000bytes . The fast:async:* can corrupt blockchain database in case of a system crash. It should not corrupt if just monerod crashes. If you are concerned with system crashes use safe:sync . --max-concurrency Max number of threads to use for a parallel jobs. The default value 0 uses the number of CPU threads. --prep-blocks-threads Max number of threads to use when computing block hashes (PoW) in groups. Defaults to 4. Decrease this if you don't want monerod hog your computer when syncing. --fast-block-sync Sync up most of the way by using embedded, \"known\" block hashes. Pass 1 to turn on and 0 to turn off. This is on ( 1 ) by default. Normally, for every block the full node must calculate the block hash to verify miner's proof of work. Because the CryptoNight PoW used in Monero is very expensive (even for verification), monerod offers skipping these calculations for old blocks. In other words, it's a mechanism to trust monerod binary regarding old blocks' PoW validity, to sync up faster. --block-sync-size How many blocks are processed in a single batch during chain synchronization. By default this is 20 blocks for newer history and 100 blocks for older history (\"pre v4\"). Default behavior is represented by value 0 . Intuitively, the more resources you have, the bigger batch size you may want to try out. Example: ./monerod --block-sync-size=500 --bootstrap-daemon-address The host:port of a \"bootstrap\" remote open node that the connected wallets can use while this node is still not fully synced. Example: ./monerod --bootstrap-daemon-address=opennode.xmr-tw.org:18089 . The node will forward selected RPC calls to the bootstrap node. The wallet will handle this automatically and transparently. Obviously, such bootstraping phase has privacy implications similar to directly using a remote node. --bootstrap-daemon-login Specify username:password for the bootstrap daemon login (if required). This considers the RPC interface used by the wallet. Normally, open nodes do not require any credentials. Mining \u00b6 The following options configure solo mining using CPU with the standard software stack monerod . This is mostly useful for: generating your stagenet or testnet coins experimentation and learning if you have super cheap access to vast CPU resources Be advised though that real mining happens in pools and with high-end GPU-s instead of CPU-s. Option Description --start-mining Specify wallet address to mining for. This must be a main address ! It can be neither a subaddres nor integrated address. --mining-threads Specify mining threads count. By default ony one thread will be used. For best results, set it to number of your physical cores. --extra-messages-file Specify file for extra messages to include into coinbase transactions. --bg-mining-enable Enable unobtrusive mining. In this mode mining will use a small percentage of your system resources to never noticeably slow down your computer. This is intended to encourage people to mine to improve decentralization. That being said chances of finding a block are diminishingly small with solo CPU mining, and even lesser with its unobtrusive version. You can tweak the unobtrusivness / power trade-offs with the further --bg-* options below. --bg-mining-ignore-battery If true, assumes plugged in when unable to query system power status. --bg-mining-min-idle-interval Specify min lookback interval in seconds for determining idle state. --bg-mining-idle-threshold Specify minimum avg idle percentage over lookback interval. --bg-mining-miner-target Specify maximum percentage cpu use by miner(s). Testing Monero itself \u00b6 These options are useful for Monero project developers and testers. Normal users shouldn't be concerned with these. Option Description --test-drop-download For net tests: in download, discard ALL blocks instead checking/saving them (very fast). --test-drop-download-height Like test-drop-download but discards only after around certain height. By default 0 . --regtest Run in a regression testing mode. --fixed-difficulty Fixed difficulty used for testing. By default 0 . --test-dbg-lock-sleep Sleep time in ms, defaults to 0 (off), used to debug before/after locking mutex. Values 100 to 1000 are good for tests. --save-graph Save data for dr Monero. Legacy \u00b6 These options should no longer be necessary. They are still present in monerod for backwards compatibility. Option Description --fluffy-blocks Relay compact blocks. Default. Compact block is just a header and a list of transaction IDs. --no-fluffy-blocks Relay classic full blocks. Classic block contains all transactions. --show-time-stats Official docs say \"Show time-stats when processing blocks/txs and disk synchronization\" but it does not seem to produce any output during usual blockchain synchronization. --zmq-rpc-bind-ip IP for ZMQ RPC server to listen on. By default 127.0.0.1 . This is not yet widely used as ZMQ interface currently does not provide meaningful advantage over classic JSON-RPC interface. Unfortunately, currently there is no way to disable the ZMQ server. --zmq-rpc-bind-port Port for ZMQ RPC server to listen on. By default 18082 for mainnet, 38082 for stagenet, and 28082 for testnet. --db-type Specify database type. The default and only available: lmdb . Commands \u00b6 Commands give access to specific services provided by the daemon. Commands are executed against the running daemon. Their names follow the command_name pattern. The following groups are only to make reference easier to follow. The daemon itself does not group commands in any way. See running for example usage. You can also type commands directly in the console of the running monerod (if not detached). Help, version, status \u00b6 Option Description help [<command>] Show help for <command> . version Show version information. Example output: Monero 'Beryllium Bullet' (v0.13.0.2-release) status Show status. Example output: Height: 186754/186754 (100.0%) on stagenet, not mining, net hash 317 H/s, v9, up to date, 8(out)+0(in) connections, uptime 0d 3h 48m 47s P2P network \u00b6 Option Description print_pl Show the full peer list. print_pl_stats Show the full peer list statistics (white vs gray peers). White peers are online and reachable. Grey peers are offline but your monerod remembers them from past sessions. print_cn Show connected peers with connection initiative (incoming/outgoing) and other stats. ban <IP> [<seconds>] Ban a given <IP> for a given amount of <seconds> . By default the ban is for 24h. Example: ./monerod ban 187.63.135.161 . unban <IP> Unban a given <IP> . bans Show the currently banned IPs. Example output: 187.63.135.161 banned for 86397 seconds . in_peers <max_number> Set the of incoming connections from other peers. out_peers <max_number> Set the of outgoing connections to other peers. limit [<kB/s>] Get or set the download and upload limit. limit_down [<kB/s>] Get or set the download limit. limit_up [<kB/s>] Get or set the upload limit. Transaction pool \u00b6 Option Description flush_txpool [<txid>] Flush specified transaction from transactions pool, or flush the whole transactions pool if was not provided. print_pool Print the transaction pool using a verbose format. print_pool_sh Print the transaction pool using a short format. print_pool_stats Print the transaction pool's statistics (number of transactions, memory size, fees, double spend attempts etc). Transactions \u00b6 Option Description print_coinbase_tx_sum <start_height> [<block_count>] Show a sum of all emitted coins and paid fees within specified range. Example: ./monerod print_coinbase_tx_sum 0 1000000000000 print_tx <transaction_hash> [+hex] [+json] Show specified transaction as JSON and/or HEX. relay_tx <txid> Force relaying the transaction. Useful if you want to rebroadcast the transaction for any reason or if transaction was previously created with \"do_not_relay\":true. Blockchain \u00b6 Option Description print_height Show local blockchain height. sync_info Show blockchain sync progress and connected peers along with download / upload stats. print_bc <begin_height> [<end_height>] Show blocks in range <begin_height> .. <end_height> . The information will include block id, height, timestamp, version, size, weight, number of non-coinbase transactions, difficulty, nonce, and reward. print_block <block_hash> | <block_height> Show detailed data of specified block. hard_fork_info Show current consensus version and future hard fork block height, if any. is_key_image_spent <key_image> Check if specified key image is spent. Key image is a hash. Manage daemon \u00b6 Option Description exit , stop_daemon Ask daemon to exit gracefully. The exit and stop_daemon are identical (one is alias of the other). set_log <level>|<{+,-,}categories> Set the current log level/categories where <level> is a number 0-4. print_status Show if daemon is running. update (check|download) Check if update is available and optionally download it. The hash is SHA-256. On linux use sha256sum to verify. Example output: Update available: v0.13.0.4: https://downloads.getmonero.org/cli/monero-linux-x64-v0.13.0.4.tar.bz2, hash 693e1a0210201f65138ace679d1ab1928aca06bb6e679c20d8b4d2d8717e50d6 Update downloaded to: /opt/monero-v0.13.0.2/monero-linux-x64-v0.13.0.4.tar.bz2 Mining \u00b6 Option Description show_hr Ask monerod daemon to stop printing current hash rate. Relevant only if monerod is mining. hide_hr Ask monerod daemon to print current hash rate. Relevant only if monerod is mining. start_mining <addr> [<threads>] [do_background_mining] [ignore_battery] Ask monerod daemon to start mining. Block reward will go to <addr> . stop_mining Ask monerod daemon to stop mining. Testing Monero itself \u00b6 Option Description start_save_graph Start saving data for dr Monero. stop_save_graph Stop saving data for dr Monero. Legacy \u00b6 Option Description save Flush blockchain data to disk. This is normally no longer necessary as monerod saves the blockchain automatically on exit. output_histogram [@<amount>] <min_count> [<max_count>] Show number of outputs for each amount denomination. This was only relevant in the pre-RingCT era. The old wallet used this to determine which outputs can be used for the requested mixin. With RingCT denominations are irrelevant as amounts are hidden. More info in these SA answers .","title":"monerod"},{"location":"interacting/monerod-reference/#monerod-reference","text":"","title":"monerod - Reference"},{"location":"interacting/monerod-reference/#overview","text":"","title":"Overview"},{"location":"interacting/monerod-reference/#connects-you-to-monero-network","text":"The Monero daemon monerod keeps your computer synced up with the Monero network. It downloads and validates the blockchain from the p2p network.","title":"Connects you to Monero network"},{"location":"interacting/monerod-reference/#not-aware-of-your-private-keys","text":"monerod is entirely decoupled from your wallet. monerod does not access your private keys - it is not aware of your transactions and balance. This allows you to run monerod on a separate computer or in the cloud. In fact, you can connect to a remote monerod instance provided by a semi-trusted 3rd party. Such 3rd party will not be able to steal your funds. This is very handy for learning and experimentation. However, there are privacy and reliability implications to using a remote, untrusted node. For any real business you should be running your own full node .","title":"Not aware of your private keys"},{"location":"interacting/monerod-reference/#syntax","text":"./monerod [options] [command] Options define how the daemon should be working. Their names follow the --option-name pattern. Commands give access to specific services provided by the daemon. Commands are executed against the running daemon. Their names follow the command_name pattern.","title":"Syntax"},{"location":"interacting/monerod-reference/#running","text":"Go to directory where you unpacked Monero. The stagenet is what your should be using for learning and experimentation. ./monerod --stagenet --detach # run as a daemon in background tail -f ~/.bitmonero/stagenet/bitmonero.log # watch the logs ./monerod --stagenet exit # ask daemon to exit gracefully The mainnnet is when you want to deal with the real XMR. ./monerod --detach # run as a daemon in background tail -f ~/.bitmonero/bitmonero.log # watch the logs ./monerod exit # ask daemon to exit gracefully","title":"Running"},{"location":"interacting/monerod-reference/#options","text":"Options define how the daemon should be working. Their names follow the --option-name pattern. The following groups are only to make reference easier to follow. The daemon itself does not group options in any way.","title":"Options"},{"location":"interacting/monerod-reference/#help-and-version","text":"Option Description --help Enlist available options. --version Show monerod version to stdout. Example: Monero 'Lithium Luna' (v0.12.3.0-release) --os-version Show build timestamp and target operating system. Example output: OS: Linux #1 SMP PREEMPT Fri Aug 24 12:48:58 UTC 2018 4.18.5-arch1-1-ARCH .","title":"Help and version"},{"location":"interacting/monerod-reference/#pick-network","text":"Option Description (missing) By default monerod assumes mainnet . --stagenet Run on stagenet . Remember to run your wallet with --stagenet as well. --testnet Run on testnet . Remember to run your wallet with --testnet as well.","title":"Pick network"},{"location":"interacting/monerod-reference/#logging","text":"Option Description --log-file Full path to the log file. Example (mind file permissions): ./monerod --log-file=/var/log/monero/mainnet/monerod.log --log-level 0-4 with 0 being minimal logging and 4 being full tracing. Defaults to 0 . These are general presets and do not directly map to severity levels. For example, even with minimal 0 , you may see some most important INFO entries. Temporarily changing to 1 allows for much better understanding of how the full node operates. Example: ./monerod --log-level=1 --max-log-file-size Soft limit in bytes for the log file (=104850000 by default, which is just under 100MB). Once log file grows past that limit, monerod creates the next log file with a UTC timestamp postfix -YYYY-MM-DD-HH-MM-SS . In production deployments, you would probably prefer to use established solutions like logrotate instead. In that case, set --max-log-file-size=0 to prevent monerod from managing the log files. --max-log-files Limit on the number of log files (=50 by default). The oldest log files are removed. In production deployments, you would probably prefer to use established solutions like logrotate instead.","title":"Logging"},{"location":"interacting/monerod-reference/#server","text":"monerod defaults are adjusted for running it occasionally on the same computer as your Monero wallet. The following options will be helpful if you intend to have an always running node \u2014 most likely on a remote server or your own separate PC. Option Description --config-file Full path to the configuration file . By default monerod looks for bitmonero.conf in Monero data directory . --data-dir Full path to data directory. This is where the blockchain, log files, and p2p network memory are stored. For defaults and details see data directory . --pidfile Full path to the PID file. Works only with --detach . Example: ./monerod --detach --pidfile=/run/monero/monerod.pid --detach Go to background (decouple from the terminal). This is useful for long-running / server scenarios. Typically, you will also want to manage monerod daemon with systemd or similar. By default monerod runs in a foreground. --non-interactive Do not require tty in a foreground mode. Helpful when running in a container. By default monerod runs in a foreground and opens stdin for reading. This breaks containerization because no tty gets assigned and monerod process crashes. You can make it run in a background with --detach but this is inconvenient in a containerized environment because the canonical usage is that the container waits on the main process to exist (forking makes things more complicated). --no-igd Disable UPnP port mapping on the router (\"Internet Gateway Device\"). Add this option to improve security if you are not behind a NAT (you can bind directly to public IP or you run through Tor). --max-txpool-weight Set maximum transactions pool size in bytes. By default 648000000 (~618MB). These are transactions pending for confirmations (not included in any block). --enforce-dns-checkpointing The emergency checkpoints set by MoneroPulse operators will be enforced. It is probably a good idea to set enforcing for unattended nodes. If encountered block hash does not match corresponding checkpoint, the local blockchain will be rolled back a few blocks, effectively blocking following what MoneroPulse operators consider invalid fork. The log entry will be produced: ERROR Local blockchain failed to pass a checkpoint, rolling back! Eventually, the alternative (\"fixed\") fork will get heavier and the node will follow it, leaving the \"invalid\" fork behind. By default checkpointing only notifies about discrepancy by producing the following log entry: ERROR WARNING: local blockchain failed to pass a MoneroPulse checkpoint, and you could be on a fork. You should either sync up from scratch, OR download a fresh blockchain bootstrap, OR enable checkpoint enforcing with the --enforce-dns-checkpointing command-line option . Reference: source code . --disable-dns-checkpoints The MoneroPulse checkpoints set by core developers will be discarded. The checkpoints are apparently still fetched though.","title":"Server"},{"location":"interacting/monerod-reference/#p2p-network","text":"The following options define how your node participates in Monero peer-to-peer network. This is for node-to-node communication. The following options do not affect wallet-to-node interface. The node and peer words are used interchangeably. Option Description --p2p-bind-ip Network interface to bind to for p2p network protocol. Default value 0.0.0.0 binds to all network interfaces. This is typically what you want. You must change this if you want to constrain binding, for example to configure connection through Tor via torsocks: DNS_PUBLIC=tcp://1.1.1.1 TORSOCKS_ALLOW_INBOUND=1 torsocks ./monerod --p2p-bind-ip 127.0.0.1\u200a--no-igd\u200a--hide-my-port --p2p-bind-port TCP port to listen for p2p network connections. Defaults to 18080 for mainnet, 28080 for testnet, and 38080 for stagenet. You normally wouldn't change that. This is helpful to run several nodes on your machine to simulate private Monero p2p network (likely using private Testnet). Example: ./monerod --p2p-bind-port=48080 --p2p-external-port TCP port to listen for p2p network connections on your router. Relevant if you are behind a NAT and still want to accept incoming connections. You must then set this to relevant port on your router. This is to let monerod know what to advertise on the network. Default is 0 . --hide-my-port monerod will still open and listen on the p2p port. However, it will not announce itself as a peer list candidate. Technically, it will return port 0 in a response to p2p handshake ( node_data.my_port = 0 in get_local_node_data function). In effect nodes you connect to won't spread your IP to other nodes. To sum up, it is not really hiding, it is more like \"do not advertise\". --seed-node Connect to a node to retrieve other nodes' addresses, and disconnect. If not specified, monerod will use hardcoded seed nodes on the first run, and peers cached on disk on subsequent runs. --add-peer Manually add node to local peer list. --add-priority-node Specify list of nodes to connect to and then attempt to keep the connection open. To add multiple nodes use the option several times. Example: ./monerod --add-priority-node=178.128.192.138:18081 --add-priority-node=144.76.202.167:18081 --add-exclusive-node Specify list of nodes to connect to only. If this option is given the options --add-priority-node and --seed-node are ignored. To add multiple nodes use the option several times. Example: ./monerod --add-exclusive-node=178.128.192.138:18081 --add-exclusive-node=144.76.202.167:18081 --out-peers Set max number of outgoing connections to other nodes. By default 8. Value -1 represents the code default. --in-peers Set max number of incoming connections (nodes actively connecting to you). By default unlimited. Value -1 represents the code default. --limit-rate-up Set outgoing data transfer limit [kB/s]. By default 2048 kB/s. Value -1 represents the code default. --limit-rate-down Set incoming data transfer limit [kB/s]. By default 8192 kB/s. Value -1 represents the code default. --limit-rate Set the same limit value for incoming and outgoing data transfer. By default ( -1 ) the individual up/down default limits will be used. It is better to use --limit-rate-up and --limit-rate-down instead to avoid confusion. --offline Do not listen for peers, nor connect to any. Useful for working with a local, archival blockchain. --allow-local-ip Allow adding local IP to peer list. Useful mostly for debug purposes when you may want to have multiple nodes on a single machine.","title":"P2P network"},{"location":"interacting/monerod-reference/#node-rpc-api","text":"monerod node offers powerful API. It serves 3 purposes: provides network data (stats, blocks, transactions, ...) provides local node information (peer list, hash rate if mining, ...) provides interface for wallets (send transactions, ...) This API is typically referred to as \"RPC\" because it is mostly based on JSON/RPC standard. The following options define how the API behaves. Option Description --rpc-bind-ip IP to listen on. By default 127.0.0.1 because API gives full administrative capabilities over the node. Set it to 0.0.0.0 to listen on all interfaces - but only in connection with one of *-restricted-* options and --confirm-external-bind . --rpc-bind-port TCP port to listen on. By default 18081 (mainnet), 28081 (testnet), 38081 (stagenet). --rpc-restricted-bind-port TCP port to listen on with the limited version of API. The limited API can be made public to create an Open Node. At the same time, you may firewall the full API port to still enjoy local querying and administration. --confirm-external-bind Confirm you consciously set --rpc-bind-ip to non-localhost IP and you understand the consequences. --restricted-rpc Restrict API to view only commands and do not return privacy sensitive data. Note this does not make sense with --rpc-restricted-bind-port because you would end up with two restricted APIs. --rpc-login Specify username[:password] required to connect to API. Practical usage seems limited because API communication is in plain text over HTTP. --rpc-access-control-origins Specify a comma separated list of origins to allow cross origin resource sharing. This is useful if you want to use monerod API directly from a web browser via JavaScript (say in a pure-fronted web appp scenario). With this option monerod will put proper HTTP CORS headers to its responses. You will also need to set --rpc-login if you use this option. Normally though, the API is used by backend app and this option isn't necessary.","title":"Node RPC API"},{"location":"interacting/monerod-reference/#accepting-monero","text":"Option Description --block-notify Run a program for each new block. The argument must be a full path . If the argument contains %s it will be replaced by the block hash. Example: ./monerod --block-notify=\"/usr/bin/echo %s\" Couple of notes: 1) Block notifications are good for immediate reaction. However, you should always assume you will miss some block notifications and you should independently poll the API to cover this up. 2) Mind blockchain reorganizations. Block notifications can revert to same and past heights. This actually happens pretty often. 3) See also --tx-notify option of monero-wallet-rpc daemon here .","title":"Accepting Monero"},{"location":"interacting/monerod-reference/#performance","text":"These are advanced options that allow you to optimize performance of your monerod node, sometimes at the expense of reliability. Option Description --db-sync-mode Specify sync option, using format: [safe|fast|fastest]:[sync|async]:[<nblocks_per_sync>[blocks]|<nbytes_per_sync>[bytes]] The default is fast:async:250000000bytes . The fast:async:* can corrupt blockchain database in case of a system crash. It should not corrupt if just monerod crashes. If you are concerned with system crashes use safe:sync . --max-concurrency Max number of threads to use for a parallel jobs. The default value 0 uses the number of CPU threads. --prep-blocks-threads Max number of threads to use when computing block hashes (PoW) in groups. Defaults to 4. Decrease this if you don't want monerod hog your computer when syncing. --fast-block-sync Sync up most of the way by using embedded, \"known\" block hashes. Pass 1 to turn on and 0 to turn off. This is on ( 1 ) by default. Normally, for every block the full node must calculate the block hash to verify miner's proof of work. Because the CryptoNight PoW used in Monero is very expensive (even for verification), monerod offers skipping these calculations for old blocks. In other words, it's a mechanism to trust monerod binary regarding old blocks' PoW validity, to sync up faster. --block-sync-size How many blocks are processed in a single batch during chain synchronization. By default this is 20 blocks for newer history and 100 blocks for older history (\"pre v4\"). Default behavior is represented by value 0 . Intuitively, the more resources you have, the bigger batch size you may want to try out. Example: ./monerod --block-sync-size=500 --bootstrap-daemon-address The host:port of a \"bootstrap\" remote open node that the connected wallets can use while this node is still not fully synced. Example: ./monerod --bootstrap-daemon-address=opennode.xmr-tw.org:18089 . The node will forward selected RPC calls to the bootstrap node. The wallet will handle this automatically and transparently. Obviously, such bootstraping phase has privacy implications similar to directly using a remote node. --bootstrap-daemon-login Specify username:password for the bootstrap daemon login (if required). This considers the RPC interface used by the wallet. Normally, open nodes do not require any credentials.","title":"Performance"},{"location":"interacting/monerod-reference/#mining","text":"The following options configure solo mining using CPU with the standard software stack monerod . This is mostly useful for: generating your stagenet or testnet coins experimentation and learning if you have super cheap access to vast CPU resources Be advised though that real mining happens in pools and with high-end GPU-s instead of CPU-s. Option Description --start-mining Specify wallet address to mining for. This must be a main address ! It can be neither a subaddres nor integrated address. --mining-threads Specify mining threads count. By default ony one thread will be used. For best results, set it to number of your physical cores. --extra-messages-file Specify file for extra messages to include into coinbase transactions. --bg-mining-enable Enable unobtrusive mining. In this mode mining will use a small percentage of your system resources to never noticeably slow down your computer. This is intended to encourage people to mine to improve decentralization. That being said chances of finding a block are diminishingly small with solo CPU mining, and even lesser with its unobtrusive version. You can tweak the unobtrusivness / power trade-offs with the further --bg-* options below. --bg-mining-ignore-battery If true, assumes plugged in when unable to query system power status. --bg-mining-min-idle-interval Specify min lookback interval in seconds for determining idle state. --bg-mining-idle-threshold Specify minimum avg idle percentage over lookback interval. --bg-mining-miner-target Specify maximum percentage cpu use by miner(s).","title":"Mining"},{"location":"interacting/monerod-reference/#testing-monero-itself","text":"These options are useful for Monero project developers and testers. Normal users shouldn't be concerned with these. Option Description --test-drop-download For net tests: in download, discard ALL blocks instead checking/saving them (very fast). --test-drop-download-height Like test-drop-download but discards only after around certain height. By default 0 . --regtest Run in a regression testing mode. --fixed-difficulty Fixed difficulty used for testing. By default 0 . --test-dbg-lock-sleep Sleep time in ms, defaults to 0 (off), used to debug before/after locking mutex. Values 100 to 1000 are good for tests. --save-graph Save data for dr Monero.","title":"Testing Monero itself"},{"location":"interacting/monerod-reference/#legacy","text":"These options should no longer be necessary. They are still present in monerod for backwards compatibility. Option Description --fluffy-blocks Relay compact blocks. Default. Compact block is just a header and a list of transaction IDs. --no-fluffy-blocks Relay classic full blocks. Classic block contains all transactions. --show-time-stats Official docs say \"Show time-stats when processing blocks/txs and disk synchronization\" but it does not seem to produce any output during usual blockchain synchronization. --zmq-rpc-bind-ip IP for ZMQ RPC server to listen on. By default 127.0.0.1 . This is not yet widely used as ZMQ interface currently does not provide meaningful advantage over classic JSON-RPC interface. Unfortunately, currently there is no way to disable the ZMQ server. --zmq-rpc-bind-port Port for ZMQ RPC server to listen on. By default 18082 for mainnet, 38082 for stagenet, and 28082 for testnet. --db-type Specify database type. The default and only available: lmdb .","title":"Legacy"},{"location":"interacting/monerod-reference/#commands","text":"Commands give access to specific services provided by the daemon. Commands are executed against the running daemon. Their names follow the command_name pattern. The following groups are only to make reference easier to follow. The daemon itself does not group commands in any way. See running for example usage. You can also type commands directly in the console of the running monerod (if not detached).","title":"Commands"},{"location":"interacting/monerod-reference/#help-version-status","text":"Option Description help [<command>] Show help for <command> . version Show version information. Example output: Monero 'Beryllium Bullet' (v0.13.0.2-release) status Show status. Example output: Height: 186754/186754 (100.0%) on stagenet, not mining, net hash 317 H/s, v9, up to date, 8(out)+0(in) connections, uptime 0d 3h 48m 47s","title":"Help, version, status"},{"location":"interacting/monerod-reference/#p2p-network_1","text":"Option Description print_pl Show the full peer list. print_pl_stats Show the full peer list statistics (white vs gray peers). White peers are online and reachable. Grey peers are offline but your monerod remembers them from past sessions. print_cn Show connected peers with connection initiative (incoming/outgoing) and other stats. ban <IP> [<seconds>] Ban a given <IP> for a given amount of <seconds> . By default the ban is for 24h. Example: ./monerod ban 187.63.135.161 . unban <IP> Unban a given <IP> . bans Show the currently banned IPs. Example output: 187.63.135.161 banned for 86397 seconds . in_peers <max_number> Set the of incoming connections from other peers. out_peers <max_number> Set the of outgoing connections to other peers. limit [<kB/s>] Get or set the download and upload limit. limit_down [<kB/s>] Get or set the download limit. limit_up [<kB/s>] Get or set the upload limit.","title":"P2P network"},{"location":"interacting/monerod-reference/#transaction-pool","text":"Option Description flush_txpool [<txid>] Flush specified transaction from transactions pool, or flush the whole transactions pool if was not provided. print_pool Print the transaction pool using a verbose format. print_pool_sh Print the transaction pool using a short format. print_pool_stats Print the transaction pool's statistics (number of transactions, memory size, fees, double spend attempts etc).","title":"Transaction pool"},{"location":"interacting/monerod-reference/#transactions","text":"Option Description print_coinbase_tx_sum <start_height> [<block_count>] Show a sum of all emitted coins and paid fees within specified range. Example: ./monerod print_coinbase_tx_sum 0 1000000000000 print_tx <transaction_hash> [+hex] [+json] Show specified transaction as JSON and/or HEX. relay_tx <txid> Force relaying the transaction. Useful if you want to rebroadcast the transaction for any reason or if transaction was previously created with \"do_not_relay\":true.","title":"Transactions"},{"location":"interacting/monerod-reference/#blockchain","text":"Option Description print_height Show local blockchain height. sync_info Show blockchain sync progress and connected peers along with download / upload stats. print_bc <begin_height> [<end_height>] Show blocks in range <begin_height> .. <end_height> . The information will include block id, height, timestamp, version, size, weight, number of non-coinbase transactions, difficulty, nonce, and reward. print_block <block_hash> | <block_height> Show detailed data of specified block. hard_fork_info Show current consensus version and future hard fork block height, if any. is_key_image_spent <key_image> Check if specified key image is spent. Key image is a hash.","title":"Blockchain"},{"location":"interacting/monerod-reference/#manage-daemon","text":"Option Description exit , stop_daemon Ask daemon to exit gracefully. The exit and stop_daemon are identical (one is alias of the other). set_log <level>|<{+,-,}categories> Set the current log level/categories where <level> is a number 0-4. print_status Show if daemon is running. update (check|download) Check if update is available and optionally download it. The hash is SHA-256. On linux use sha256sum to verify. Example output: Update available: v0.13.0.4: https://downloads.getmonero.org/cli/monero-linux-x64-v0.13.0.4.tar.bz2, hash 693e1a0210201f65138ace679d1ab1928aca06bb6e679c20d8b4d2d8717e50d6 Update downloaded to: /opt/monero-v0.13.0.2/monero-linux-x64-v0.13.0.4.tar.bz2","title":"Manage daemon"},{"location":"interacting/monerod-reference/#mining_1","text":"Option Description show_hr Ask monerod daemon to stop printing current hash rate. Relevant only if monerod is mining. hide_hr Ask monerod daemon to print current hash rate. Relevant only if monerod is mining. start_mining <addr> [<threads>] [do_background_mining] [ignore_battery] Ask monerod daemon to start mining. Block reward will go to <addr> . stop_mining Ask monerod daemon to stop mining.","title":"Mining"},{"location":"interacting/monerod-reference/#testing-monero-itself_1","text":"Option Description start_save_graph Start saving data for dr Monero. stop_save_graph Stop saving data for dr Monero.","title":"Testing Monero itself"},{"location":"interacting/monerod-reference/#legacy_1","text":"Option Description save Flush blockchain data to disk. This is normally no longer necessary as monerod saves the blockchain automatically on exit. output_histogram [@<amount>] <min_count> [<max_count>] Show number of outputs for each amount denomination. This was only relevant in the pre-RingCT era. The old wallet used this to determine which outputs can be used for the requested mixin. With RingCT denominations are irrelevant as amounts are hidden. More info in these SA answers .","title":"Legacy"},{"location":"interacting/overview/","text":"Interacting with Monero \u00b6 You can interact with Monero via desktop GUI, commandline interface, and programming API. On top of that, Monero nodes interact with each other in a peer-to-peer network. Installation directory overview \u00b6 Once unpacked you will see several executable files. You will also find a nice PDF guide for the GUI wallet. Monero project nicely decouples network node logic from wallet logic. Wallet logic is offered through three independent user interfaces - the GUI, the CLI, and the HTTP API. # cd monero-gui-v0.13.0.3 # ---- guide to Monero GUI ---- monero-GUI-guide.pdf # ---- executable files ----------- monerod monero-wallet-cli monero-wallet-gui monero-wallet-rpc monero-gen-trusted-multisig monero-blockchain-export monero-blockchain-import monero-blockchain-mark-spent-outputs monero-blockchain-usage monero-blockchain-ancestry monero-blockchain-depth start-gui.sh # ---- directories ---------------- libs plugins qml Executables - what is what \u00b6 Executable Description monerod The full node daemon. Does not require a wallet. Documentation . monero-wallet-gui Wallet logic and graphical user interface. Requires monerod running. monero-wallet-cli Wallet logic and commandline user interface. Requires monerod running. monero-wallet-rpc Wallet logic and HTTP API (JSON-RPC protocol). Requires monerod running. monero-blockchain-export Tool to export blockchain to blockchain.raw file. monero-blockchain-import Tool to import blockchain.raw - ideally your own trusted copy. monero-gen-trusted-multisig Tool to generate a set of multisig wallets. See chapter on multisignatures . monero-blockchain-mark-spent-outputs Advanced tool to mitigate potential privacy issues related to Monero forks. You normally shouldn't be concerned with that. See the commit and pull request . monero-blockchain-usage Advanced tool to mitigate potential privacy issues related to Monero forks. You normally shouldn't be concerned with that. See the commit and the pull request . monero-blockchain-ancestry Advanced research tool to learn ancestors of a transaction, block or chain. Irrelevant for normal users. See this pull request . monero-blockchain-depth Advanced research tool to learn depth of a transaction, block or chain. Irrelevant for normal users. See this commit . Interacting \u00b6 There are quite a few ways you can interact with Monero software. Perhaps the most surprising for newcomers is that monerod daemon accepts interactive keyboard commands while it is running. Also, please note that HTTP API is split across monerod and monero-wallet-rpc . You need to run and call both daemons to explore the full API. This follows the node-logic vs wallet-logic split mentioned earlier. All wallet implementations depend on the monerod running. Executable p2p network node commands via keyboard node HTTP API wallet commands via keyboard wallet HTTP API wallet via GUI monerod \u2714 \u2714 \u2714 monero-wallet-cli \u2714 monero-wallet-rpc \u2714 monero-wallet-gui \u2714 Data directory \u00b6 This is where the blockchain, log files, and p2p network memory are stored. By default data directory is at: $HOME/.bitmonero/ on Linux $HOME/Library/Application\\ Support/ on macOS C:\\ProgramData\\bitmonero\\ on Windows Please mind: data directory is hidden as per OS convention the bitmonero directory name is historical artefact from before Monero forked away from Bitmonero, about 2000 years Before Christ Data directory contains: lmdb/ - the blockchain database directory p2pstate.bin - saved memory of discovered and rated peers bitmonero.log - log file It can also contain subdirectories for stagenet and testnet, mirroring the same structure: stagenet/ - data directory for Stagenet testnet/ - data directory for Testnet","title":"Overview"},{"location":"interacting/overview/#interacting-with-monero","text":"You can interact with Monero via desktop GUI, commandline interface, and programming API. On top of that, Monero nodes interact with each other in a peer-to-peer network.","title":"Interacting with Monero"},{"location":"interacting/overview/#installation-directory-overview","text":"Once unpacked you will see several executable files. You will also find a nice PDF guide for the GUI wallet. Monero project nicely decouples network node logic from wallet logic. Wallet logic is offered through three independent user interfaces - the GUI, the CLI, and the HTTP API. # cd monero-gui-v0.13.0.3 # ---- guide to Monero GUI ---- monero-GUI-guide.pdf # ---- executable files ----------- monerod monero-wallet-cli monero-wallet-gui monero-wallet-rpc monero-gen-trusted-multisig monero-blockchain-export monero-blockchain-import monero-blockchain-mark-spent-outputs monero-blockchain-usage monero-blockchain-ancestry monero-blockchain-depth start-gui.sh # ---- directories ---------------- libs plugins qml","title":"Installation directory overview"},{"location":"interacting/overview/#executables-what-is-what","text":"Executable Description monerod The full node daemon. Does not require a wallet. Documentation . monero-wallet-gui Wallet logic and graphical user interface. Requires monerod running. monero-wallet-cli Wallet logic and commandline user interface. Requires monerod running. monero-wallet-rpc Wallet logic and HTTP API (JSON-RPC protocol). Requires monerod running. monero-blockchain-export Tool to export blockchain to blockchain.raw file. monero-blockchain-import Tool to import blockchain.raw - ideally your own trusted copy. monero-gen-trusted-multisig Tool to generate a set of multisig wallets. See chapter on multisignatures . monero-blockchain-mark-spent-outputs Advanced tool to mitigate potential privacy issues related to Monero forks. You normally shouldn't be concerned with that. See the commit and pull request . monero-blockchain-usage Advanced tool to mitigate potential privacy issues related to Monero forks. You normally shouldn't be concerned with that. See the commit and the pull request . monero-blockchain-ancestry Advanced research tool to learn ancestors of a transaction, block or chain. Irrelevant for normal users. See this pull request . monero-blockchain-depth Advanced research tool to learn depth of a transaction, block or chain. Irrelevant for normal users. See this commit .","title":"Executables - what is what"},{"location":"interacting/overview/#interacting","text":"There are quite a few ways you can interact with Monero software. Perhaps the most surprising for newcomers is that monerod daemon accepts interactive keyboard commands while it is running. Also, please note that HTTP API is split across monerod and monero-wallet-rpc . You need to run and call both daemons to explore the full API. This follows the node-logic vs wallet-logic split mentioned earlier. All wallet implementations depend on the monerod running. Executable p2p network node commands via keyboard node HTTP API wallet commands via keyboard wallet HTTP API wallet via GUI monerod \u2714 \u2714 \u2714 monero-wallet-cli \u2714 monero-wallet-rpc \u2714 monero-wallet-gui \u2714","title":"Interacting"},{"location":"interacting/overview/#data-directory","text":"This is where the blockchain, log files, and p2p network memory are stored. By default data directory is at: $HOME/.bitmonero/ on Linux $HOME/Library/Application\\ Support/ on macOS C:\\ProgramData\\bitmonero\\ on Windows Please mind: data directory is hidden as per OS convention the bitmonero directory name is historical artefact from before Monero forked away from Bitmonero, about 2000 years Before Christ Data directory contains: lmdb/ - the blockchain database directory p2pstate.bin - saved memory of discovered and rated peers bitmonero.log - log file It can also contain subdirectories for stagenet and testnet, mirroring the same structure: stagenet/ - data directory for Stagenet testnet/ - data directory for Testnet","title":"Data directory"},{"location":"interacting/verify-monero-binaries/","text":"Verify Monero Binaries \u00b6 Verification must be carried on before extracting the archive and before using Monero . Instructions were tested on Linux. They should also work on macOS with slight modifications. 0. Import core dev PGP key \u00b6 This is a one time action. Skip this step for subsequent Monero releases. Monero core developers sign a list of hashes of released binaries. Riccardo \"fluffypony\" Spagni is Monero core developer who signs the releases. Riccardo's public key is available on GitHub in the project source code. Import Riccardo's public key to your keyring: curl https://raw.githubusercontent.com/monero-project/monero/master/utils/gpg_keys/fluffypony.asc | gpg --import Trust Riccardo's public key (fingerprint must be exactly this): gpg --edit-key 'BDA6BD7042B721C467A9759D7455C5E3C0CDCEB9' trust 4 Danger If key with this fingerprint was not found then remove imported key immediately (gpg --delete-keys ...). That would mean the key changed (likely was compromised). 1. Verify signature of hash list \u00b6 The list of binaries and their hashes is published on getmonero.org and a few other places like release notes on r/monero . Please note the publication channel does not matter as long as you properly verify the signature! u To verify these are real hashes (not tampered with) run: curl https://www.getmonero.org/downloads/hashes.txt | gpg --verify The expected output is: ... gpg: Good signature from \"Riccardo Spagni <ric@spagni.net>\" [full] 2. Verify the hash \u00b6 By this step we checked that published hashes were not tampered with. The last step is to compare published hash with downloaded archive SHA-256 hash. Download Monero if you didn't already (but do not unpack). Replace the example file name with actual one: file_name=monero-linux-x64-v0.13.0.4.tar.bz2 file_hash=`sha256sum $file_name | cut -c 1-64` curl https://www.getmonero.org/downloads/hashes.txt > /tmp/reference-hashes.txt # verify the signature (previous step is repeated here for completeness) gpg --verify /tmp/reference-hashes.txt # grep must print the hash (output cannot be empty) grep $file_hash /tmp/reference-hashes.txt Danger If the grep output is empty then double check everything because apparently the hashes don't match. If grep printed filename and a hash then everything is alright!","title":"Verify"},{"location":"interacting/verify-monero-binaries/#verify-monero-binaries","text":"Verification must be carried on before extracting the archive and before using Monero . Instructions were tested on Linux. They should also work on macOS with slight modifications.","title":"Verify Monero Binaries"},{"location":"interacting/verify-monero-binaries/#0-import-core-dev-pgp-key","text":"This is a one time action. Skip this step for subsequent Monero releases. Monero core developers sign a list of hashes of released binaries. Riccardo \"fluffypony\" Spagni is Monero core developer who signs the releases. Riccardo's public key is available on GitHub in the project source code. Import Riccardo's public key to your keyring: curl https://raw.githubusercontent.com/monero-project/monero/master/utils/gpg_keys/fluffypony.asc | gpg --import Trust Riccardo's public key (fingerprint must be exactly this): gpg --edit-key 'BDA6BD7042B721C467A9759D7455C5E3C0CDCEB9' trust 4 Danger If key with this fingerprint was not found then remove imported key immediately (gpg --delete-keys ...). That would mean the key changed (likely was compromised).","title":"0. Import core dev PGP key"},{"location":"interacting/verify-monero-binaries/#1-verify-signature-of-hash-list","text":"The list of binaries and their hashes is published on getmonero.org and a few other places like release notes on r/monero . Please note the publication channel does not matter as long as you properly verify the signature! u To verify these are real hashes (not tampered with) run: curl https://www.getmonero.org/downloads/hashes.txt | gpg --verify The expected output is: ... gpg: Good signature from \"Riccardo Spagni <ric@spagni.net>\" [full]","title":"1. Verify signature of hash list"},{"location":"interacting/verify-monero-binaries/#2-verify-the-hash","text":"By this step we checked that published hashes were not tampered with. The last step is to compare published hash with downloaded archive SHA-256 hash. Download Monero if you didn't already (but do not unpack). Replace the example file name with actual one: file_name=monero-linux-x64-v0.13.0.4.tar.bz2 file_hash=`sha256sum $file_name | cut -c 1-64` curl https://www.getmonero.org/downloads/hashes.txt > /tmp/reference-hashes.txt # verify the signature (previous step is repeated here for completeness) gpg --verify /tmp/reference-hashes.txt # grep must print the hash (output cannot be empty) grep $file_hash /tmp/reference-hashes.txt Danger If the grep output is empty then double check everything because apparently the hashes don't match. If grep printed filename and a hash then everything is alright!","title":"2. Verify the hash"},{"location":"proof-of-work/cryptonight/","text":"CryptoNight \u00b6 CryptoNight is a memory hard hash function Background \u00b6 CryptoNight was originally designed around 2013 as part of the CryptoNote suite. One design goal was to make it very friendly for the off-the-shelf CPU-s, by employing: native AES encryption fast 64 bit multipliers scratchpad fitting exactly the size of the per-core L3 cache on Intel CPUs (about 2MB) More ambitious design goal was to make it inefficiently computable on ASIC-s. This goal has since failed, as it inevitably happens with \"ASIC hard\" algorithms. Efficient CryptoNight ASIC was developed in 2017 by Bitmain. Monero inherited CryptoNight as its proof of work in 2014. Since then Monero slightly evolved the algorithm to intentionally break compatibility with released ASIC-s. Currently Monero implements CryptoNight v2, a third iteration of original CryptoNight. The goal is to find small-enough hash \u00b6 In hashing based PoW algorithms the goal is to find small-enough hash. Hash is simply an integer (normally, a very large integer). Most hashing functions result in 256-bit hashes (integers between 0 and 2^256). This includes Bitcoin's double-SHA-256 and Monero's CryptoNight. Miner randomly tweaks input data until the hash fits under specified threshold. The threshold (also a large integer) is established collectively by the network as part of the consensus mechanism. The PoW is only considered valid (solved) if hash fits under the threshold. Because hash functions are one-way, it is not possible to analytically calculate input data that would result in a small-enough hash. The solution must be brute-forced by tweaking the input data and recalculating the hash over and over again. Miners have a few areas of flexibility regarding input data - most importantly they can iterate with the nonce value. They also have a power over which transactions are included in the block and how they are put together in a merkle tree. Cryptographic primitives \u00b6 CryptoNight is based on: AES encryption 5 hashing functions, all of which were finalist in NIST SHA-3 competition: Keccak (the primary one) BLAKE Groestl JH Skein Input data \u00b6 In Monero the input to hashing function is concatenation of: serialized block header (around 46 bytes; subject to varint representation) merkle tree root (32 bytes) number of transactions included in the block (around 1-2 bytes; subject to varint representation) See get_block_hashing_blob() function to dig further. Algorithm \u00b6 Warning The article attempts to give reader a high-level understanding of the CryptoNight algorithm. For implementation details refer to CryptoNote Standard and Monero source code. See references at the bottom. Overview \u00b6 CryptoNight attempts to make memory access a bottleneck for performance (\"memory hardness\"). It has three steps: Initialize large area of memory with pseudo-random data. This memory is known as the scratchpad. Perform numerous read/write operations at pseudo-random addresses on the scratchpad. Hash the entire scratchpad to produce the resulting value. Step 1: scratchpad initialization \u00b6 Firstly, the input data is hashed with Keccak-1600. This results in 200 bytes of pseudorandom data (1600 bits == 200 bytes). These 200 bytes become a seed to generate a larger, 2MB-wide buffer of pseudorandom data, by applying AES-256 encryption. The first 0..31 bytes of Keccak-1600 hash are used as AES key. The encryption is performed on 128 bytes-long payloads until 2MB is ready. The first payload are Keccak-1600 bytes 66..191. The next payload is encryption result of the previous payload. Each 128-byte payload is actually encrypted 10 times. The details are a bit more nuanced, see \"Scratchpad Initialization\" on CryptoNote Standard . Step 2: memory-hard loop \u00b6 The second step is basically 524288 iterations of a simple stateful algorithm. Each algorithm iteration reads from and writes back to the scratchpad, at pseudorandom-but-deterministic locations. Critically, next iteration depends on the state prepared by previous iterations. It is not possible to directly calculate state of future iterations. The specific operations include AES, XOR, 8byte_mul, 8byte_add - operations that are CPU-friendly (highly optimized on modern CPU-s). The goal here is to make memory latency the bottleneck in attempt to close the gap between potential ASIC-s and general purpose CPU-s. Step 3: hashing \u00b6 The final step (simplifying) is to: combine original Keccak-1600 output with the whole scratchpad pick the hashing algorithm based on 2 low-order bits of the result 0=BLAKE-256 1=Groestl-256 2=JH-256 3=Skein-256 hash the result with selected function The resulting 256-bit hash is the final output of CryptoNight algorithm. Monero specific modifications \u00b6 CryptoNight v0 \u00b6 This is how Monero refers to original implementation of CryptoNight. CryptoNight v1 \u00b6 See the source code diff for CryptoNight v1 modifications. CryptoNight v2 \u00b6 The v2 changes were more involved. See the rationale and the source code diff . Critique \u00b6 CryptoNight hash is relatively expensive to verify. This poses a risk of DoS-ing nodes with incorrect proofs to process. See strong asymmetry requirement. The hash function was designed from scratch with limited peer review. While CryptoNight is composed of proven and peer-reviewed primitives, combining secure primitives doesn't necessarily result in a secure cryptosystem. CryptoNight ultimately failed to prevent ASIC-s. Complexity of CryptoNight kills competition in ASIC manufacturing. CryptoNight proof of work remains one of the most controversial aspect of Monero. Reference \u00b6 CryptoNight hash function description in the CryptoNote Standard CryptoNight v2 source code The entry point is cn_slow_hash() function. Manually removing support and optimizations for multiple architectures should help you understand the actual code. \"Egalitarian Proof of Work\" chapter in CryptoNote whitepaper First days of Monero mining by dr David Andersen Some test vectors in Monero source code","title":"CryptoNight"},{"location":"proof-of-work/cryptonight/#cryptonight","text":"CryptoNight is a memory hard hash function","title":"CryptoNight"},{"location":"proof-of-work/cryptonight/#background","text":"CryptoNight was originally designed around 2013 as part of the CryptoNote suite. One design goal was to make it very friendly for the off-the-shelf CPU-s, by employing: native AES encryption fast 64 bit multipliers scratchpad fitting exactly the size of the per-core L3 cache on Intel CPUs (about 2MB) More ambitious design goal was to make it inefficiently computable on ASIC-s. This goal has since failed, as it inevitably happens with \"ASIC hard\" algorithms. Efficient CryptoNight ASIC was developed in 2017 by Bitmain. Monero inherited CryptoNight as its proof of work in 2014. Since then Monero slightly evolved the algorithm to intentionally break compatibility with released ASIC-s. Currently Monero implements CryptoNight v2, a third iteration of original CryptoNight.","title":"Background"},{"location":"proof-of-work/cryptonight/#the-goal-is-to-find-small-enough-hash","text":"In hashing based PoW algorithms the goal is to find small-enough hash. Hash is simply an integer (normally, a very large integer). Most hashing functions result in 256-bit hashes (integers between 0 and 2^256). This includes Bitcoin's double-SHA-256 and Monero's CryptoNight. Miner randomly tweaks input data until the hash fits under specified threshold. The threshold (also a large integer) is established collectively by the network as part of the consensus mechanism. The PoW is only considered valid (solved) if hash fits under the threshold. Because hash functions are one-way, it is not possible to analytically calculate input data that would result in a small-enough hash. The solution must be brute-forced by tweaking the input data and recalculating the hash over and over again. Miners have a few areas of flexibility regarding input data - most importantly they can iterate with the nonce value. They also have a power over which transactions are included in the block and how they are put together in a merkle tree.","title":"The goal is to find small-enough hash"},{"location":"proof-of-work/cryptonight/#cryptographic-primitives","text":"CryptoNight is based on: AES encryption 5 hashing functions, all of which were finalist in NIST SHA-3 competition: Keccak (the primary one) BLAKE Groestl JH Skein","title":"Cryptographic primitives"},{"location":"proof-of-work/cryptonight/#input-data","text":"In Monero the input to hashing function is concatenation of: serialized block header (around 46 bytes; subject to varint representation) merkle tree root (32 bytes) number of transactions included in the block (around 1-2 bytes; subject to varint representation) See get_block_hashing_blob() function to dig further.","title":"Input data"},{"location":"proof-of-work/cryptonight/#algorithm","text":"Warning The article attempts to give reader a high-level understanding of the CryptoNight algorithm. For implementation details refer to CryptoNote Standard and Monero source code. See references at the bottom.","title":"Algorithm"},{"location":"proof-of-work/cryptonight/#overview","text":"CryptoNight attempts to make memory access a bottleneck for performance (\"memory hardness\"). It has three steps: Initialize large area of memory with pseudo-random data. This memory is known as the scratchpad. Perform numerous read/write operations at pseudo-random addresses on the scratchpad. Hash the entire scratchpad to produce the resulting value.","title":"Overview"},{"location":"proof-of-work/cryptonight/#step-1-scratchpad-initialization","text":"Firstly, the input data is hashed with Keccak-1600. This results in 200 bytes of pseudorandom data (1600 bits == 200 bytes). These 200 bytes become a seed to generate a larger, 2MB-wide buffer of pseudorandom data, by applying AES-256 encryption. The first 0..31 bytes of Keccak-1600 hash are used as AES key. The encryption is performed on 128 bytes-long payloads until 2MB is ready. The first payload are Keccak-1600 bytes 66..191. The next payload is encryption result of the previous payload. Each 128-byte payload is actually encrypted 10 times. The details are a bit more nuanced, see \"Scratchpad Initialization\" on CryptoNote Standard .","title":"Step 1: scratchpad initialization"},{"location":"proof-of-work/cryptonight/#step-2-memory-hard-loop","text":"The second step is basically 524288 iterations of a simple stateful algorithm. Each algorithm iteration reads from and writes back to the scratchpad, at pseudorandom-but-deterministic locations. Critically, next iteration depends on the state prepared by previous iterations. It is not possible to directly calculate state of future iterations. The specific operations include AES, XOR, 8byte_mul, 8byte_add - operations that are CPU-friendly (highly optimized on modern CPU-s). The goal here is to make memory latency the bottleneck in attempt to close the gap between potential ASIC-s and general purpose CPU-s.","title":"Step 2: memory-hard loop"},{"location":"proof-of-work/cryptonight/#step-3-hashing","text":"The final step (simplifying) is to: combine original Keccak-1600 output with the whole scratchpad pick the hashing algorithm based on 2 low-order bits of the result 0=BLAKE-256 1=Groestl-256 2=JH-256 3=Skein-256 hash the result with selected function The resulting 256-bit hash is the final output of CryptoNight algorithm.","title":"Step 3: hashing"},{"location":"proof-of-work/cryptonight/#monero-specific-modifications","text":"","title":"Monero specific modifications"},{"location":"proof-of-work/cryptonight/#cryptonight-v0","text":"This is how Monero refers to original implementation of CryptoNight.","title":"CryptoNight v0"},{"location":"proof-of-work/cryptonight/#cryptonight-v1","text":"See the source code diff for CryptoNight v1 modifications.","title":"CryptoNight v1"},{"location":"proof-of-work/cryptonight/#cryptonight-v2","text":"The v2 changes were more involved. See the rationale and the source code diff .","title":"CryptoNight v2"},{"location":"proof-of-work/cryptonight/#critique","text":"CryptoNight hash is relatively expensive to verify. This poses a risk of DoS-ing nodes with incorrect proofs to process. See strong asymmetry requirement. The hash function was designed from scratch with limited peer review. While CryptoNight is composed of proven and peer-reviewed primitives, combining secure primitives doesn't necessarily result in a secure cryptosystem. CryptoNight ultimately failed to prevent ASIC-s. Complexity of CryptoNight kills competition in ASIC manufacturing. CryptoNight proof of work remains one of the most controversial aspect of Monero.","title":"Critique"},{"location":"proof-of-work/cryptonight/#reference","text":"CryptoNight hash function description in the CryptoNote Standard CryptoNight v2 source code The entry point is cn_slow_hash() function. Manually removing support and optimizations for multiple architectures should help you understand the actual code. \"Egalitarian Proof of Work\" chapter in CryptoNote whitepaper First days of Monero mining by dr David Andersen Some test vectors in Monero source code","title":"Reference"},{"location":"proof-of-work/pow-in-cryptocurrencies/","text":"Proof of Work in Cryptocurrencies \u00b6 Proof of work is a Sybil protection mechanism PoW protects against Sybil attack \u00b6 In decentralized cryptocurrencies untrusted actors sign (blocks of) transactions. If threshold voting was employed then the scheme would break immediately. This is because nothing prevents a single actor from creating arbitrary number of pseudonyms and take over the voting. In distributed systems this is known as Sybil attack. Instead, cryptocurrencies employ proof of work. In the proof of work scheme, it is not the number of actors that counts. It is the amount of committed computational resources. This, of course, is much harder to game. To endanger the scheme, an attacker would have to actually control majority (>50%) of computational resources. In practice, attacker would need this control over significant period of time. PoW is a leader election mechanism \u00b6 In distributed systems \"leader election\" is a process of establishing which node is responsible for (temporarily) coordinating the system. In cryptocurrencies PoW is used to elect the node that \"wins\" the next block. Using PoW for leader election was one of the key inventions introduced by Bitcoin. Competing nodes (known as \"miners\") work on a solution to artificial problem. Every now and then, someone randomly finds the solution. Chances are linearly proportional to committed computing power. The winner uses its solution to \"underwrite\" the block it assembled. Only blocks with valid solutions are accepted by the network. The winner also gets a reward for its work. The reward is a specific amount of cryptocurrency created \"out of thin air\" and assigned to self. The winner also gets all fees coming from transactions included in the block. The difficulty of the PoW problem is dynamically adjusted by the network, with the goal of finding blocks with a roughly constant rate (typically, every couple of minutes).","title":"PoW in Cryptocurrencies"},{"location":"proof-of-work/pow-in-cryptocurrencies/#proof-of-work-in-cryptocurrencies","text":"Proof of work is a Sybil protection mechanism","title":"Proof of Work in Cryptocurrencies"},{"location":"proof-of-work/pow-in-cryptocurrencies/#pow-protects-against-sybil-attack","text":"In decentralized cryptocurrencies untrusted actors sign (blocks of) transactions. If threshold voting was employed then the scheme would break immediately. This is because nothing prevents a single actor from creating arbitrary number of pseudonyms and take over the voting. In distributed systems this is known as Sybil attack. Instead, cryptocurrencies employ proof of work. In the proof of work scheme, it is not the number of actors that counts. It is the amount of committed computational resources. This, of course, is much harder to game. To endanger the scheme, an attacker would have to actually control majority (>50%) of computational resources. In practice, attacker would need this control over significant period of time.","title":"PoW protects against Sybil attack"},{"location":"proof-of-work/pow-in-cryptocurrencies/#pow-is-a-leader-election-mechanism","text":"In distributed systems \"leader election\" is a process of establishing which node is responsible for (temporarily) coordinating the system. In cryptocurrencies PoW is used to elect the node that \"wins\" the next block. Using PoW for leader election was one of the key inventions introduced by Bitcoin. Competing nodes (known as \"miners\") work on a solution to artificial problem. Every now and then, someone randomly finds the solution. Chances are linearly proportional to committed computing power. The winner uses its solution to \"underwrite\" the block it assembled. Only blocks with valid solutions are accepted by the network. The winner also gets a reward for its work. The reward is a specific amount of cryptocurrency created \"out of thin air\" and assigned to self. The winner also gets all fees coming from transactions included in the block. The difficulty of the PoW problem is dynamically adjusted by the network, with the goal of finding blocks with a roughly constant rate (typically, every couple of minutes).","title":"PoW is a leader election mechanism"},{"location":"proof-of-work/what-is-pow/","text":"Proof of Work \u00b6 Proof of work is a way to legitimize untrusted party What exactly is proof of work? \u00b6 Proof of work is a cryptographic proof that untrusted party committed significant computational resources to solve artificial problem. Technically, the \"proof\" is simply a solution to the problem at hand. It's all about legitimizing untrusted party \u00b6 How an untrusted party on the Internet could earn any level of your trust? It can prove its commitment by solving agreed computationally hard problem. For example, by requiring untrusted party to perform a hard computation before you accept their connection, you limit connections only to \"committed\" parties. In another example, you could require PoW to be attached to incoming e-mails to make spam prohibitively expensive. Work must be otherwise useless \u00b6 The work on and solution to \"computationally hard problem\" cannot be useful in any other way than to prove the commitment. If the work is useful elsewhere then it doesn't prove commitment to you. The problem must be artificial. Otherwise incentives are skewed and the whole scheme breaks. Strong asymmetry \u00b6 The requirement for proof of work scheme is strong asymmetry for work vs verification resources. The work must be arbitrarily hard. At the same time proof verification must remain dirt cheap (in terms of computational resources). Cheap verification is critical because at this stage we are dealing with potentially huge number of untrusted parties, who could DoS the verifier by submitting invalid proofs. Such proofs should be trivial to discard.","title":"What is PoW?"},{"location":"proof-of-work/what-is-pow/#proof-of-work","text":"Proof of work is a way to legitimize untrusted party","title":"Proof of Work"},{"location":"proof-of-work/what-is-pow/#what-exactly-is-proof-of-work","text":"Proof of work is a cryptographic proof that untrusted party committed significant computational resources to solve artificial problem. Technically, the \"proof\" is simply a solution to the problem at hand.","title":"What exactly is proof of work?"},{"location":"proof-of-work/what-is-pow/#its-all-about-legitimizing-untrusted-party","text":"How an untrusted party on the Internet could earn any level of your trust? It can prove its commitment by solving agreed computationally hard problem. For example, by requiring untrusted party to perform a hard computation before you accept their connection, you limit connections only to \"committed\" parties. In another example, you could require PoW to be attached to incoming e-mails to make spam prohibitively expensive.","title":"It's all about legitimizing untrusted party"},{"location":"proof-of-work/what-is-pow/#work-must-be-otherwise-useless","text":"The work on and solution to \"computationally hard problem\" cannot be useful in any other way than to prove the commitment. If the work is useful elsewhere then it doesn't prove commitment to you. The problem must be artificial. Otherwise incentives are skewed and the whole scheme breaks.","title":"Work must be otherwise useless"},{"location":"proof-of-work/what-is-pow/#strong-asymmetry","text":"The requirement for proof of work scheme is strong asymmetry for work vs verification resources. The work must be arbitrarily hard. At the same time proof verification must remain dirt cheap (in terms of computational resources). Cheap verification is critical because at this stage we are dealing with potentially huge number of untrusted parties, who could DoS the verifier by submitting invalid proofs. Such proofs should be trivial to discard.","title":"Strong asymmetry"},{"location":"public-address/integrated-address/","text":"Integrated Address \u00b6 Integrated addresses are ideal for accepting Monero in an automated fashion - like in online stores and exchanges. Monero integrated address embeds a payment ID. This allows you to learn for what you are being paid. Please note these are Monero technical payment IDs and must not be confused with business identifiers like order number or invoice number. The transaction to integrated address will not reveal the payment ID publicly. Payment ID in a transaction will be encrypted with a shared secret (one-time random key known only to sender and recipient). Only the recipient will be able to match the transaction against payment ID. Monero integrated address obsoletes the former practice of using full 32-bytes payment ID in a transaction extra field (where it was not encrypted). Data structure ( src ): Index Size in bytes Description 0 1 identifies the network and address type; 19 - main chain; 54 - test chain 1 32 public spend key 33 32 public view key 65 8 compact payment ID - 8 bytes randomly generated by the recipient; note that it does not need encryption in the address itself but it is hidden in a transaction paying to integrated address to prevent linking payment with the address by external observers 73 4 checksum ( Keccak-f[1600] hash of the previous 73 bytes, trimmed to first 4 bytes) It totals to 77 bytes. The bytes are then encoded ( src ) in Monero specific Base58 format, resulting in a 106 chars long string. Example integrated address: 4LL9oSLmtpccfufTMvppY6JwXNouMBzSkbLYfpAV5Usx3skxNgYeYTRj5UzqtReoS44qo9mtmXCqY45DJ852K5Jv2bYXZKKQePHES9khPK Integrated addresses vs subaddresses \u00b6 Both types allow you to learn for what you are being paid. Individuals should prefer subaddresses to receive payments. This is to improve privacy in certain scenarios. See article on subaddresses for details. Businesses accepting payments in an automated way should prefer integrated addresses . The rationale is as follows: Scenario where subaddresses improve privacy is not applicable to businesses b/c businesses have the same identity over time. Consequently, subaddresses provide no benefits over integrated addresses. No private key is necessary to generate integrated address. This provides a strong security advantage because services that generate integrated addresses need no access to wallet. In contrast, to generate a subaddress, one needs a private view key. No shared counter is necessary to generate integrated address. This allows individual services to independently generate integrated addresses w/o synchronizing on a common sequence. In contrast, subaddresses are generated sequentially, and so the sequence (the counter or index) is a coupling point between the wallet and all services that need to generate the address. Back to integrated addresses, note that embedded payment IDs are 64-bit. This means the space is large enough that one can simply generate them randomly and reliably assume uniqueness. In very specific scenarios, preparation effort to monitor a very huge number of subaddresses, could became an issue. See this reddit thread for details. Caveats \u00b6 There are some caveates: Single transaction cannot pay to multiple integrated addresses. As individual running a wallet you should generally prefer subaddresses. However, if you happen to use integrated addresses, you should allow Monero software to generate integrated addresses for you (instead of forcing your own payment IDs). Reference \u00b6 question on StackExchange","title":"Integrated"},{"location":"public-address/integrated-address/#integrated-address","text":"Integrated addresses are ideal for accepting Monero in an automated fashion - like in online stores and exchanges. Monero integrated address embeds a payment ID. This allows you to learn for what you are being paid. Please note these are Monero technical payment IDs and must not be confused with business identifiers like order number or invoice number. The transaction to integrated address will not reveal the payment ID publicly. Payment ID in a transaction will be encrypted with a shared secret (one-time random key known only to sender and recipient). Only the recipient will be able to match the transaction against payment ID. Monero integrated address obsoletes the former practice of using full 32-bytes payment ID in a transaction extra field (where it was not encrypted). Data structure ( src ): Index Size in bytes Description 0 1 identifies the network and address type; 19 - main chain; 54 - test chain 1 32 public spend key 33 32 public view key 65 8 compact payment ID - 8 bytes randomly generated by the recipient; note that it does not need encryption in the address itself but it is hidden in a transaction paying to integrated address to prevent linking payment with the address by external observers 73 4 checksum ( Keccak-f[1600] hash of the previous 73 bytes, trimmed to first 4 bytes) It totals to 77 bytes. The bytes are then encoded ( src ) in Monero specific Base58 format, resulting in a 106 chars long string. Example integrated address: 4LL9oSLmtpccfufTMvppY6JwXNouMBzSkbLYfpAV5Usx3skxNgYeYTRj5UzqtReoS44qo9mtmXCqY45DJ852K5Jv2bYXZKKQePHES9khPK","title":"Integrated Address"},{"location":"public-address/integrated-address/#integrated-addresses-vs-subaddresses","text":"Both types allow you to learn for what you are being paid. Individuals should prefer subaddresses to receive payments. This is to improve privacy in certain scenarios. See article on subaddresses for details. Businesses accepting payments in an automated way should prefer integrated addresses . The rationale is as follows: Scenario where subaddresses improve privacy is not applicable to businesses b/c businesses have the same identity over time. Consequently, subaddresses provide no benefits over integrated addresses. No private key is necessary to generate integrated address. This provides a strong security advantage because services that generate integrated addresses need no access to wallet. In contrast, to generate a subaddress, one needs a private view key. No shared counter is necessary to generate integrated address. This allows individual services to independently generate integrated addresses w/o synchronizing on a common sequence. In contrast, subaddresses are generated sequentially, and so the sequence (the counter or index) is a coupling point between the wallet and all services that need to generate the address. Back to integrated addresses, note that embedded payment IDs are 64-bit. This means the space is large enough that one can simply generate them randomly and reliably assume uniqueness. In very specific scenarios, preparation effort to monitor a very huge number of subaddresses, could became an issue. See this reddit thread for details.","title":"Integrated addresses vs subaddresses"},{"location":"public-address/integrated-address/#caveats","text":"There are some caveates: Single transaction cannot pay to multiple integrated addresses. As individual running a wallet you should generally prefer subaddresses. However, if you happen to use integrated addresses, you should allow Monero software to generate integrated addresses for you (instead of forcing your own payment IDs).","title":"Caveats"},{"location":"public-address/integrated-address/#reference","text":"question on StackExchange","title":"Reference"},{"location":"public-address/main-address/","text":"Address \u00b6 Monero public address is what you publish to get paid. An address can be generated offline and for free. It boils down to generating a large random number representing your private spending key. Publishing your Monero address does not endanger your privacy. That's because in Monero transactions go to stealth addresses which are decoupled from your public address. There are a few types of public addresses in Monero: Main address - basic type of an address, also refered to as raw address Subaddress - what you should be using by default Integrated address - relevant for exchanges, merchants, and other businesses accepting Monero in a fully automated way Main address \u00b6 Historicaly, raw address was the only available option. For that reason it is the most widely adopted and supported address type. Its strength is simplicity. However, these days users should prefer receiving to subaddresses instead. Technically, raw address is also a basis for creating subaddresses and integrated addresses. Raw address is still useful for : accepting block reward in a solo-mining scenario as other addresses are not supported accepting from senders who batch payouts (like mining pools); in this scenario the sender is paying multiple parties using a single transaction; such transaction has multiple outputs; subaddresses do not work in this scenario accepting from senders who use legacy wallets (can't send to subaddress) Monero raw address is composed of two public keys: public spend key public view key It also contains a checksum and a \"network byte\" which actually identifies both the network and the address type. Data structure ( src ): Index Size in bytes Description 0 1 identifies the network and address type; 18 - main chain; 53 - test chain 1 32 public spend key 33 32 public view key 65 4 checksum ( Keccak-f[1600] hash of the previous 65 bytes, trimmed to first 4 bytes) It totals to 69 bytes. The bytes are then encoded ( src ) in Monero specific Base58 format, resulting in a 95 chars long string. Example main address: 4AdUndXHHZ6cfufTMvppY6JwXNouMBzSkbLYfpAV5Usx3skxNgYeYTRj5UzqtReoS44qo9mtmXCqY45DJ852K5Jv2684Rge Generating \u00b6 Main address is derived from the root private key. Reference \u00b6 StackExchenge answer https://xmr.llcoins.net/addresstests.html","title":"Main"},{"location":"public-address/main-address/#address","text":"Monero public address is what you publish to get paid. An address can be generated offline and for free. It boils down to generating a large random number representing your private spending key. Publishing your Monero address does not endanger your privacy. That's because in Monero transactions go to stealth addresses which are decoupled from your public address. There are a few types of public addresses in Monero: Main address - basic type of an address, also refered to as raw address Subaddress - what you should be using by default Integrated address - relevant for exchanges, merchants, and other businesses accepting Monero in a fully automated way","title":"Address"},{"location":"public-address/main-address/#main-address","text":"Historicaly, raw address was the only available option. For that reason it is the most widely adopted and supported address type. Its strength is simplicity. However, these days users should prefer receiving to subaddresses instead. Technically, raw address is also a basis for creating subaddresses and integrated addresses. Raw address is still useful for : accepting block reward in a solo-mining scenario as other addresses are not supported accepting from senders who batch payouts (like mining pools); in this scenario the sender is paying multiple parties using a single transaction; such transaction has multiple outputs; subaddresses do not work in this scenario accepting from senders who use legacy wallets (can't send to subaddress) Monero raw address is composed of two public keys: public spend key public view key It also contains a checksum and a \"network byte\" which actually identifies both the network and the address type. Data structure ( src ): Index Size in bytes Description 0 1 identifies the network and address type; 18 - main chain; 53 - test chain 1 32 public spend key 33 32 public view key 65 4 checksum ( Keccak-f[1600] hash of the previous 65 bytes, trimmed to first 4 bytes) It totals to 69 bytes. The bytes are then encoded ( src ) in Monero specific Base58 format, resulting in a 95 chars long string. Example main address: 4AdUndXHHZ6cfufTMvppY6JwXNouMBzSkbLYfpAV5Usx3skxNgYeYTRj5UzqtReoS44qo9mtmXCqY45DJ852K5Jv2684Rge","title":"Main address"},{"location":"public-address/main-address/#generating","text":"Main address is derived from the root private key.","title":"Generating"},{"location":"public-address/main-address/#reference","text":"StackExchenge answer https://xmr.llcoins.net/addresstests.html","title":"Reference"},{"location":"public-address/subaddress/","text":"Subaddress \u00b6 Subaddress is what you should be using by default to receive Monero. Learn for what you are being paid \u00b6 By providing a unique subaddress for each anticipated payment you will know for what you are being paid. This use case overlaps with integrated addresses. Subaddresses are generally prefered for reasons outlined below. Prevent payer from linking your payouts together \u00b6 To prevent the payer from linking your payouts together simply generate a new subaddress for each payout. This way services like Shapeshift wouldn't know it is you again receving Monero. Note it won't help if you have an account with the service. Then your payouts are already linked in the service database, regardless of Monero. Group funds into accounts \u00b6 Note Feel free to skip this if your are new to Monero. Accounts are not essential and currently not supported by the GUI. Accounts are a convenience wallet-level feature to group subaddresses under one label and balance. You may want to organize your funds into accounts like \"cash\", \"work\", \"trading\", \"mining\", \"donations\", etc. As accounts are only groupings of subaddresses, they themselves do not have an address. Accounts are deterministically derived from the root private key along with subaddresses. As of September 2018 accounts are only supported by the CLI wallet and missing from GUI wallet. Accounts are similar to subaccounts in your classic bank account. There is a very important difference though. In Monero funds don't really sit on accounts or public addresses. Public addresses are conceptually a gateway or a routing mechanism. Funds sit on transactions' unspent outputs. Thus, a single transaction can - in principle - aggregate and spend outputs from multiple addresses (and by extension from multiple accounts). The CLI or GUI wallet may not directly support creating such transactions for simplicity. In short, think of accounts as a soft grouping of your funds. Why not multiple wallets? \u00b6 The advantage over creating multiple wallets is that you only have a single seed to manage. All subaddresses can be derived from the wallet seed. Additionally, you conveniently manage your subaddresses within a single user interface. Wallet level feature \u00b6 Subaddresses and accounts are a wallet-level feature to construct and interpret transactions. They do not affect the consensus. Data structure \u00b6 Subaddress has a dedicated \"network byte\": Index Size in bytes Description 0 1 identifies the network and address type; 42 - main chain; 63 - test chain Otherwise the data structure is the same as for main address . Each subaddress conceptually has an index (with 0 being the main address). The index is not directly included in subaddress structure but is used as input to create the private view key. Generating \u00b6 The private view key m for a subaddress is derived as follows: m = Hs(a || i) Where: Hs is a Keccak-256 hash function interpreted as integer and modulo l (maximum edwards25519 scalar) a is a private view key of the base address i is a subaddress index Deriving \"sub view keys\" from the \"base view key\" allows for creating a view only wallet that monitors entire wallet including subaddresses. Caveates \u00b6 It is not recommended to sweep all the balances of subaddress to main address in a single transaction. That links the subaddresses together on the blockchain. However, this only concerns privacy against specific sender and the situation will never get worse than not using subaddresses in the first place. If you need to join funds while preserving maximum privacy do it with individual transactions (one per subaddress). Convenience labels are not preserved when recreating from seed. Reference \u00b6 https://github.com/monero-project/monero/pull/2056 https://www.reddit.com/r/Monero/comments/5vgjs2/subaddresses_and_disposable_addresses/","title":"Subaddress"},{"location":"public-address/subaddress/#subaddress","text":"Subaddress is what you should be using by default to receive Monero.","title":"Subaddress"},{"location":"public-address/subaddress/#learn-for-what-you-are-being-paid","text":"By providing a unique subaddress for each anticipated payment you will know for what you are being paid. This use case overlaps with integrated addresses. Subaddresses are generally prefered for reasons outlined below.","title":"Learn for what you are being paid"},{"location":"public-address/subaddress/#prevent-payer-from-linking-your-payouts-together","text":"To prevent the payer from linking your payouts together simply generate a new subaddress for each payout. This way services like Shapeshift wouldn't know it is you again receving Monero. Note it won't help if you have an account with the service. Then your payouts are already linked in the service database, regardless of Monero.","title":"Prevent payer from linking your payouts together"},{"location":"public-address/subaddress/#group-funds-into-accounts","text":"Note Feel free to skip this if your are new to Monero. Accounts are not essential and currently not supported by the GUI. Accounts are a convenience wallet-level feature to group subaddresses under one label and balance. You may want to organize your funds into accounts like \"cash\", \"work\", \"trading\", \"mining\", \"donations\", etc. As accounts are only groupings of subaddresses, they themselves do not have an address. Accounts are deterministically derived from the root private key along with subaddresses. As of September 2018 accounts are only supported by the CLI wallet and missing from GUI wallet. Accounts are similar to subaccounts in your classic bank account. There is a very important difference though. In Monero funds don't really sit on accounts or public addresses. Public addresses are conceptually a gateway or a routing mechanism. Funds sit on transactions' unspent outputs. Thus, a single transaction can - in principle - aggregate and spend outputs from multiple addresses (and by extension from multiple accounts). The CLI or GUI wallet may not directly support creating such transactions for simplicity. In short, think of accounts as a soft grouping of your funds.","title":"Group funds into accounts"},{"location":"public-address/subaddress/#why-not-multiple-wallets","text":"The advantage over creating multiple wallets is that you only have a single seed to manage. All subaddresses can be derived from the wallet seed. Additionally, you conveniently manage your subaddresses within a single user interface.","title":"Why not multiple wallets?"},{"location":"public-address/subaddress/#wallet-level-feature","text":"Subaddresses and accounts are a wallet-level feature to construct and interpret transactions. They do not affect the consensus.","title":"Wallet level feature"},{"location":"public-address/subaddress/#data-structure","text":"Subaddress has a dedicated \"network byte\": Index Size in bytes Description 0 1 identifies the network and address type; 42 - main chain; 63 - test chain Otherwise the data structure is the same as for main address . Each subaddress conceptually has an index (with 0 being the main address). The index is not directly included in subaddress structure but is used as input to create the private view key.","title":"Data structure"},{"location":"public-address/subaddress/#generating","text":"The private view key m for a subaddress is derived as follows: m = Hs(a || i) Where: Hs is a Keccak-256 hash function interpreted as integer and modulo l (maximum edwards25519 scalar) a is a private view key of the base address i is a subaddress index Deriving \"sub view keys\" from the \"base view key\" allows for creating a view only wallet that monitors entire wallet including subaddresses.","title":"Generating"},{"location":"public-address/subaddress/#caveates","text":"It is not recommended to sweep all the balances of subaddress to main address in a single transaction. That links the subaddresses together on the blockchain. However, this only concerns privacy against specific sender and the situation will never get worse than not using subaddresses in the first place. If you need to join funds while preserving maximum privacy do it with individual transactions (one per subaddress). Convenience labels are not preserved when recreating from seed.","title":"Caveates"},{"location":"public-address/subaddress/#reference","text":"https://github.com/monero-project/monero/pull/2056 https://www.reddit.com/r/Monero/comments/5vgjs2/subaddresses_and_disposable_addresses/","title":"Reference"},{"location":"todo/p2p/","text":"","title":"P2p"},{"location":"todo/risks-of-using-remote-node/","text":"Risks of using remote node \u00b6 https://monero.stackexchange.com/questions/1482/how-much-information-is-passed-from-the-daemon-to-simplewallet-when-scanning-for?rq=1%20https://monero.stackexchange.com/questions/1134/is-it-safe-to-share-a-daemon-with-a-roommate?noredirect=1&lq=1 Reference \u00b6 Reddit answer SE 1 SE 2","title":"Risks of using remote node"},{"location":"todo/risks-of-using-remote-node/#risks-of-using-remote-node","text":"https://monero.stackexchange.com/questions/1482/how-much-information-is-passed-from-the-daemon-to-simplewallet-when-scanning-for?rq=1%20https://monero.stackexchange.com/questions/1134/is-it-safe-to-share-a-daemon-with-a-roommate?noredirect=1&lq=1","title":"Risks of using remote node"},{"location":"todo/risks-of-using-remote-node/#reference","text":"Reddit answer SE 1 SE 2","title":"Reference"},{"location":"todo/tx/","text":"Monero transaction \u00b6 https://monero.stackexchange.com/questions/2136/understanding-the-structure-of-a-monero-transaction?noredirect=1&lq=1 https://monero.stackexchange.com/questions/6736/how-does-input-reference-the-output-of-some-transaction?noredirect=1&lq=1","title":"Transaction | Monero Documentation"},{"location":"todo/tx/#monero-transaction","text":"https://monero.stackexchange.com/questions/2136/understanding-the-structure-of-a-monero-transaction?noredirect=1&lq=1 https://monero.stackexchange.com/questions/6736/how-does-input-reference-the-output-of-some-transaction?noredirect=1&lq=1","title":"Monero transaction"}]}